<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一些JS题目的解答]]></title>
    <url>%2F2018%2F01%2F16%2F%E4%B8%80%E4%BA%9BJS%E9%A2%98%E7%9B%AE%E7%9A%84%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[在这里看到一些测试题，我HTML和CSS比较一般，尝试把里面的JS题目都解答一下： 1.&quot;1&quot; + 2 + &quot;3&quot; + 4 10 1234 37 答案：1234，加法优先级等同，从左往右，数字与字符串相加，数字转换成字符串进行运算，结果等同于：”12”+”3”+4 = “123”+4 = “1234”。 2.4 + 3 + 2 + &quot;1&quot; 10 4321 91 答案：91，优先级同上，从左往右，等同于：7+2+”1” = 9+”1” = “91”。 3.var foo = 1; function bar() { foo = 10; return; function foo() {} } bar(); alert(foo); 1 10 Function undefined Error 答案：1，function的定义会提前到当前作用域之前，所以等同于： var foo = 1; function bar() { function foo() {} foo = 10; return; } bar(); alert(foo); 所以，在foo=10的时候，foo是有定义的，属于局部变量，影响不到外层的foo。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope Unlike functions defined by function expressions or by the Function constructor, a function defined by a function declaration can be used before the function declaration itself. 4.function bar() { return foo; foo = 10; function foo() {} var foo = 11; } alert(typeof bar()); number function undefined Error 答案：function，与上题类似，等同于： function bar() { function foo() {} return foo; foo = 10; var foo = 11; } alert(typeof bar()); 在return之后声明和赋值的foo都无效，所以返回了function。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return A function immediately stops at the point where return is called. 补充，这个解答有问题： @尤里卡Eureka：JS中function声明和var声明都会被提前，最终得到结果为function，是因为名称解析顺序-Name Resolution Order(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~ 5.var x = 3; var foo = { x: 2, baz: { x: 1, bar: function() { return this.x; } } } var go = foo.baz.bar; alert(go()); alert(foo.baz.bar()); 1,2 1,3 2,1 2,3 3,1 3,2 答案：3,1this指向执行时刻的作用域，go的作用域是全局，所以相当于window，取到的就是window.x，也就是var x=3;这里定义的x。而foo.baz.bar()里面，this指向foo.baz，所以取到的是这个上面的x，也就是1。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FOperators%2Fthis 6.var x = 4, obj = { x: 3, bar: function() { var x = 2; setTimeout(function() { var x = 1; alert(this.x); }, 1000); } }; obj.bar(); 1 2 3 4 undefined 答案：4，不管有这个setTimeout还是把这个函数立即执行，它里面这个function都是孤立的，this只能是全局的window，即使不延时，改成立即执行结果同样是4。 7.x = 1; function bar() { this.x = 2; return x; } var foo = new bar(); alert(foo.x); 1 2 undefined 答案：2，这里主要问题是最外面x的定义，试试把x=1改成x={}，结果会不同的。这是为什么呢？在把函数当作构造器使用的时候，如果手动返回了一个值，要看这个值是否简单类型，如果是，等同于不写返回，如果不是简单类型，得到的就是手动返回的值。如果，不手动写返回值，就会默认从原型创建一个对象用于返回。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new 8.function foo(a) { alert(arguments.length); } foo(1, 2, 3); 1 2 3 undefined 答案3，arguments取的是实参的个数，而foo.length取的是形参个数。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments/length?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments%2Flength arguments.length provides the number of arguments actually passed to a function. This can be more or less than the defined parameter count (See Function.length). 9.var foo = function bar() {}; alert(typeof bar); function object undefined 答案：undefined，这种情况下bar的名字从外部不可见，那是不是这个名字别人就没法知道了呢？不是，toString就可以看到它，比如说alert(foo)，可以看看能打出什么。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope The function name can be used only within the function’s body. Attempting to use it outside the function’s body results in an error (or undefined if the function name was previously declared via a var statement). 10.var arr = []; arr[0] = &apos;a&apos;; arr[1] = &apos;b&apos;; arr.foo = &apos;c&apos;; alert(arr.length); 1 2 3 undefined 答案：2，数组的原型是Object，所以可以像其他类型一样附加属性，不影响其固有性质。 11.function foo(a) { arguments[0] = 2; alert(a); } foo(1); 1 2 undefined 答案：2，实参可以直接从arguments数组中修改。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope%2Farguments The arguments can also be set 12.function foo(){} delete foo.length; alert(typeof foo.length); number undefined object Error 答案：number，foo.length是无法删除的，它在Function原型上，重点它的configurable是false。 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete delete can’t remove certain properties of predefined objects (like Object, Array, Math etc). These are described in ECMAScript 5 and later as non-configurable]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端组件化框架之路]]></title>
    <url>%2F2017%2F07%2F14%2F%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[1. 为什么组件化这么难做Web应用的组件化是一个很复杂的话题。 在大型软件中，组件化是一种共识，它一方面提高了开发效率，另一方面降低了维护成本。但是在Web前端这个领域，并没有很通用的组件模式，因为缺少一个大家都能认同的实现方式，所以很多框架/库都实现了自己的组件化方式。 前端圈最热衷于造轮子了，没有哪个别的领域能出现这么混乱而欣欣向荣的景象。这一方面说明前端领域的创造力很旺盛，另一方面却说明了基础设施是不完善的。 我曾经有过这么一个类比，说明某种编程技术及其生态发展的几个阶段： 最初的时候人们忙着补全各种API，代表着他们拥有的东西还很匮乏，需要在语言跟基础设施上继续完善 然后就开始各种模式，标志他们做的东西逐渐变大变复杂，需要更好的组织了 然后就是各类分层MVC，MVP，MVVM之类，可视化开发，自动化测试，团队协同系统等等，说明重视生产效率了，也就是所谓工程化 那么，对比这三个阶段，看看关注这三种东西的人数，觉得Web发展到哪一步了？ 细节来说，大概是模块化和组件化标准即将大规模落地（好坏先不论），各类API也大致齐备了，终于看到起飞的希望了，各种框架几年内会有非常强力的洗牌，如果不考虑老旧浏览器的拖累，这个洗牌过程将大大加速，然后才能释放Web前端的产能。 但是我们必须注意到，现在这些即将普及的标准，很多都会给之前的工作带来改变。用工业体系的发展史来对比，前端领域目前正处于蒸汽机发明之前，早期机械（比如《木兰辞》里面的机杼，主要是动力与材料比较原始）已经普及的这么一个阶段。 所以，从这个角度看，很多框架/库是会消亡的（专门做模块化的AMD和CMD相关库，专注于标准化DOM选择器铺垫的某些库），一些则必须进行革新，还有一些受的影响会比较小（数据可视化等相关方向），可以有机会沿着自己的方向继续演进。 2. 标准的变革对于这类东西来说，能获得广泛群众基础的关键在于：对将来的标准有怎样的迎合程度。对前端编程方式可能造成重大影响的标准有这些： module Web Components class observe promise module的问题很好理解，JavaScript第一次有了语言上的模块机制，而Web Components则是约定了基于泛HTML体系构建组件库的方式，class增强了编程体验，observe提供了数据和展现分离的一种优秀方式，promise则是目前前端最流行的异步编程方式。 这里面只有两个东西是绕不过去的，一是module，一是Web Components。前者是模块化基础，后者是组件化的基础。 module的标准化，主要影响的是一些AMD/CMD的加载和相关管理系统，从这个角度来看，正如seajs团队的@afc163 所说，不管是AMD还是CMD，都过时了。 模块化相对来说，迁移还比较容易，基本只是纯逻辑的包装，跟AMD或者CMD相比，包装形式有所变化，但组件化就是个比较棘手的问题了。 Web Components提供了一种组件化的推荐方式，具体来说，就是： 通过shadow DOM封装组件的内部结构 通过Custom Element对外提供组件的标签 通过Template Element定义组件的HTML模板 通过HTML imports控制组件的依赖加载 这几种东西，会对现有的各种前端框架/库产生很巨大的影响： 由于shadow DOM的出现，组件的内部实现隐藏性更好了，每个组件更加独立，但是这使得CSS变得很破碎，LESS和SASS这样的样式框架面临重大挑战。 因为组件的隔离，每个组件内部的DOM复杂度降低了，所以选择器大多数情况下可以限制在组件内部了，常规选择器的复杂度降低，这会导致人们对jQuery的依赖下降。 又因为组件的隔离性加强，致力于建立前端组件化开发方式的各种框架/库（除Polymer外），在自己的组件实现方式与标准Web Components的结合，组件之间数据模型的同步等问题上，都遇到了不同寻常的挑战。 HTML imports和新的组件封装方式的使用，会导致之前常用的以JavaScript为主体的各类组件定义方式处境尴尬，它们的依赖、加载，都面临了新的挑战，而由于全局作用域的弱化，请求的合并变得困难得多。 3. 当下最时髦的前端组件化框架/库在年初这个时间点看，前端领域有四个框架/库引领时尚，那就是Angular，Polymer，React，Vue（排名按照首字母） 我们可以看到，Polymer这个东西在这方面是有先天优势的，因为它的核心理念就是基于Web Components的，也就是说，它基本没有考虑如何解决当前的问题，直接以未来为发展方向了。 React和Vue的编程模式其实不必特别考虑Web标准，它的迁移成本并不算高，甚至由于其实现机制，屏蔽了UI层实现方式，所以大家能看到在native上的使用，canvas上的使用，这都是与基于DOM的编程方式大为不同的，所以对它来说，处理Web Components的兼容问题要在封装标签的时候解决，反正之前也是要封装。 Angular 1.x的版本，可以说是跟同时代的多数框架/库一样，对未来标准的兼容基本没有考虑，但是重新规划之后的2.0版本对此有了很多权衡，变成了激进变更，突然就变成一个未来的东西了。 这四个东西各有千秋，在可以预见的几年内将会鼎足三分，也许还会有新的框架出现，能不能比这几个流行就难说了。 此外，原Angular 2.0的成员Rob Eisenberg创建了自己的新一代框架aurelia，该框架将成为Angular 2.0强有力的竞争者。 4. 前端组件的复用性看过了已有的一些东西之后，我们可以大致来讨论一下前端组件化的一些理念。假设我们有了某种底层的组件机制，先不管它是浏览器原生的，或者是某种框架/库实现的约定，现在打算用它来做一个大型的Web应用，应该怎么做呢？ 所谓组件化，核心意义莫过于提取真正有复用价值的东西。那怎样的东西有复用价值呢？ 控件 基础逻辑功能 公共样式 稳定的业务逻辑 对于控件的可复用性，基本上是没有争议的，因为这是实实在在的通用功能，并且比较独立。 基础逻辑功能主要指的是一些与界面无关的东西，比如underscore这样的辅助库，或者一些校验等等纯逻辑功能。 公共样式的复用性也是比较容易认可的，因此也会有bootstrap，foundation，semantic这些东西的流行，不过它们也不是纯粹的样式库了，也带有一些小的逻辑封装。 最后一块，也就是业务逻辑。这一块的复用是存在很多争议的，一方面是，很多人不认同业务逻辑也需要组件化，另一方面，这块东西究竟怎样去组件化，也很需要思考。 除了上面列出的这些之外，还有大量的业务界面，这块东西很显然复用价值很低，基本不存在复用性，但仍然有很多方案中把它们“组件化”了，使得它们成为了“不具有复用性的组件”。为什么会出现这种情况呢？ 组件化的本质目的并不一定是要为了可复用，而是提升可维护性。这一点正如面向对象语言，Java要比C++纯粹，因为它不允许例外情况的出现，连main函数都必须写到某个类里，所以Java是纯面向对象语言，而C++不是。 在我们这种情况下，也可以把组件化分为：全组件化，局部组件化。怎么理解这两个东西的区别呢，有人问过js框架和库的区别是什么，一般来说，有某种较强约定的东西，称为框架，而约定比较松散的，称为库。框架很多都是有全组件化理念的，比如说，很多年前就出现的ExtJS，它是全组件化框架，而jQuery和它的插件体系，则是局部组件化。所以用ExtJS写东西，不管写什么都是差不多一样的写法，而用jQuery的时候，大部分地方是原始HTML，哪里需要有些不一样的东西，就只在那个地方调用插件做一下特殊化。 对于一个有一定规模的Web应用来说，把所有东西都“组件化”，在管理上会有较大的便利性。我举个例子，同样是编写代码，短代码明显比长代码的可读性更高，所以很多语言里会建议“一个方法一般不要超过多少行，一个类最好不要超过多少行”之类。在Web前端这个体系里，JavaScript这块是做得相对较好的，现在入门水平的人，也已经很少会有把一堆js都写在一起的了。CSS这块，最近在SASS，LESS等框架的引领下，也逐步往模块化方面发展，否则直接编写bootstrap那种css，会非常痛苦。 这个时候我们再看HTML的部分，如果不考虑模板等技术的使用，某些界面光布局代码写起来就非常多了，像一些表单，都需要一层套一层，很多简单的表单元素都需要套个三层左右，更不必说一些有复杂布局的东西了。尤其是整个系统单页化之后，界面的header，footer，各种nav或者aside，很可能都有一定复杂性。如果这些东西的代码不作切分，那么主界面的HTML一定比较难看。 我们先不管用什么方式切分了，比如用某种模板，用类似Angular中的include，或者Polymer，React中的标签，或者直接使用原生Web Components，总之是把一块一块都拆开了，然后包含进来。从这个角度看，这些拆出去的东西都像组件，但如果从复用性的角度看，很可能多数东西，每一块都只有一个地方用，压根没有复用度。这个拆出去，纯粹是为了使得整个工程易于管理，易于维护。 这时候我们再来关注不同框架/库对UI层组件化的处理方式，发现有两个类型，模板和函数。 模板是一种很常见的东西，它用HTML字符串的方式表达界面的原始结构，然后通过代入数据的方式生成真正的界面，有的是生成目标HTML，有的还生成各种事件的自动绑定。前者是静态模板，后者是动态模板。 另外有一些框架/库偏爱用函数逻辑来生成界面，早期的ExtJS，现在的React（它内部还是可能使用模板，而且对外提供的是组件创建接口的进一步封装——jsx）等，这种实现技术的优势是不同平台上编程体验一致，甚至可以给每种平台封装相同的组件，调用方轻松写一份代码，在Web和不同Native平台上可用。但这种方式也有比较麻烦的地方，那就是界面调整比较繁琐。 本文前面部分引用侯振宇的那篇文章里，他提出这些问题： 如何能把组件变得更易重用? 具体一点: 我在用某个组件时需要重新调整一下组件里面元素的顺序怎么办? 我想要去掉组件里面某一个元素怎么办?如何把组件变得更易扩展? 具体一点: 业务方不断要求给组件加功能怎么办? 为此，还提出了“模板复写”方案，在这一点上我有不同意见。 我们来看看如何把一个业务界面切割成组件。 有这么一个简单场景：一个雇员列表界面包括两个部分，雇员表格和用于填写雇员信息的表单。在这个场景下，存在哪些组件？ 对于这个问题，主要存在两种倾向，一种是仅仅把“控件”和比较有通用性的东西封装成组件，另外一种是整个应用都组件化。 对前一种方式来说，这里面只存在数据表格这么一个组件。对后一种方式来说，这里面有可能存在：数据表格，雇员表单，甚至还包括雇员列表界面这么一个更大的组件。 这两种方式，就是我们之前所说的“局部组件化”，“全组件化”。 我们前面提到，全组件化在管理上是存在优势的，它可以把不同层面的东西都搞成类似结构，比如刚才的这个业务场景，很可能最后写起来是这个样子： 1234&lt;Employee-Panel&gt; &lt;Employee-List&gt;&lt;/Employee-List&gt; &lt;Employee-Form&gt;&lt;/Employee-Form&gt;&lt;/Employee-Panel&gt; 对于UI层，最好的组件化方式是标签化，比如上面代码中就是三个标签表达了整个界面。但我个人坚决反对滥用标签，并不是把各种东西都尽量封装就一定好。 全标签化的问题主要有这些： 第一，语义化代价太大。只要用了标签，就一定需要给它合适的语义，也就是命名。但实际用的时候，很可能只是为了把一堆html简化一下而已，到底简化出来的那东西应当叫什么名字，光是起名也费不知多少脑细胞。比如你说雇员管理的表单，这个表单有heading吗，有footer吗，能折叠吗，等等，很难起一个让别人一看就知道的名字，要么就是特别长。这还算简单的，因为我们是全组件化，所以很可能会有组合了多种东西的一个较复杂的界面，你想来想去也没法给它起个名字，于是写了个： 12&lt;Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right&gt;&lt;/Panel-With-Department-Panel-On-The-Left-And-Employee-Panel-On-The-Right&gt; 这尼玛……可能我夸张了点，但很多时候项目规模够大，你不起这么复杂的名字，最后很可能没法跟功能类似的一个组件区分开，因为这些该死的组件都存在于同一个命名空间中。如果仅仅是当作一个界面片段来include，就不存在这种心理负担了。 比如Angular里面的这种： 1&lt;div ng-include="'aaa/bbb/ccc.html'"&gt;&lt;/div&gt; 就不给它什么名字，直接include进来，用文件路径来区分。这个片段的作用可以用其目录结构描述，也就是通过物理名而非逻辑名来标识，目录层次充当了一个很好的命名空间。 现在的一些主流MVVM框架，比如knockout，angular，avalon，vue等等，都有一种“界面模板”，但这种模板并不仅仅是模板，而是可以视为一种配置文件。某一块界面模板描述了自身与数据模型的关系，当它被解析之后，按照其中的各种设置，与数据建立关联，并且反过来再更新自身所对应的视图。 不含业务逻辑的UI（或者是业务逻辑已分离的UI）基本不适合作为组件来看待，因为即使在逻辑不变的情况下，界面改版的可能性也太多了。比如即使是换了新的CSS实现方式，从float布局改成flex布局，都有可能把DOM结构少套几层div，因此，在使用模板的方案中，只能把界面层视为配置文件，不能看成组件，如果这么做，就会轻松很多。 部队行军的时候讲究“逢山开路，遇水搭桥”，这句话的重点在于只有到某些地形才开路搭桥，使用MVVM这类模式解决的业务场景，多数时候是一马平川，横着走都可以，不必硬要造路。所以从整个方案看的话，UI层实现应该是模板与控件并存，大部分地方是模板，少数地方是需要单独花时间搞的路和桥。 第二，配置过于复杂。有很多东西其实不太适合封装，不但封装的代价大，使用的代价也会很大。有时候会发现，调用代码的绝大部分都是在写各种配置。 就像刚才的雇员表单，既然你不从标签的命名上去区分，那一定会在组件上加配置。比如你原来想这样： 1&lt;EmployeeForm heading="雇员表单"&gt;&lt;/EmployeeForm&gt; 然后在组件内部，判断有没有设置heading，如果没有就不显示，如果有，就显示。过了两天，产品问能不能把heading里面的某几个字加粗或者换色，然后码农开始允许这个heading属性传入html。没多久之后，你会惊奇地发现有人用你的组件，没跟你说，就在heading里面传入了折叠按钮的html，并且用选择器给折叠按钮加了事件，点一下之后还能折叠这个表单了…… 然后你一想，这个不行，我得给他再加个配置，让他能很简单地控制折叠按钮的显示，但是现在这么写太不直观，于是采用对象结构的配置： 1234567&lt;EmployeeForm&gt; &lt;Option collapsible="true"&gt; &lt;Heading&gt; &lt;h4&gt;&lt;strong&gt;雇员&lt;/strong&gt;表单&lt;/h4&gt; &lt;/Heading&gt; &lt;/Option&gt;&lt;/EmployeeForm&gt; 然后又有一天，发现有很多面板都可以折叠，然后特意创建了一个可折叠面板组件，又创建了一种继承机制，其他普通业务面板从它继承，从此一发不可收拾。 我举这例子的意思是为了说明什么呢，我想说，在规模较大的项目中，企图用全标签化加配置的方式来描述所有的普通业务界面，是一定事倍功半的，并且这个规模越大就越坑，这也正是ExtJS这类对UI层封装过度的体系存在的最大问题。 这个问题讨论完了，我们来看看另外一个问题：如果UI组件有业务逻辑，应该如何处理。 比如说，性别选择的下拉框，它是一个非常通用化的功能，照理说是很适合被当做组件来提供的。但是究竟如何封装它，我们就有些犯难了。这个组件里除了界面，还有数据，这些数据应当内置在组件里吗？理论上从组件的封装性来说，是都应当在里面的，于是就这么造了一个组件： 1&lt;GenderSelect&gt;&lt;/GenderSelect&gt; 这个组件非常美好，只需直接放在任意的界面中，就能显示带有性别数据的下拉框了。性别的数据很自然地是放在组件的实现内部，一个写死的数组中。这个太简单了，我们改一下，改成商品销售的国家下拉框。 表面上看，这个没什么区别，但我们有个要求，本公司商品销售的国家的信息是统一配置的，也就是说，这个数据来源于服务端。这时候，你是不是想把一个http请求封装到这组件里？ 这样做也不是不可以，但存在至少两个问题： 如果这类组件在同一个界面中出现多次，就可能存在请求的浪费，因为有一个组件实例就会产生一个请求。 如果国家信息的配置界面与这个组件同时存在，当我们在配置界面中新增一个国家了，下拉框组件中的数据并不会实时刷新。 第一个问题只是资源的浪费，第二个就是数据的不一致了。曾经在很多系统中，大家都是手动刷新当前页面来解决这问题的，但到了这个时代，人们都是追求体验的，在一个全组件化的解决方案中，不应再出现此类问题。 如何解决这样的问题呢？那就是引入一层Store的概念，每个组件不直接去到服务端请求数据，而是到对应的前端数据缓存中去获取数据，让这个缓存自己去跟服务端保持同步。 所以，在实际做方案的过程中，不管是基于Angular，React，Polymer，最后肯定都做出一层Store了，不然会有很多问题。 5. 为什么MVVM是一种很好的选择我们回顾一下刚才那个下拉框的组件，发现存在几个问题： 界面不好调整。刚才的那个例子相对简单，如果我们是一个省市县三级联动的组件，就比较麻烦了。比如说，我们想要把水平布局改成垂直的，又或者，想要把中间的label的字改改，都会非常麻烦。按照传统的做组件的方式，就要加若干配置项，然后组件里面去分别判断，修改DOM结构。 如果数据的来源不是静态json，而是某个动态的服务接口，那用起来就很麻烦。 我们更多地需要业务逻辑的复用和纯“控件”的复用，至于那些绑定业务的界面组件，复用性其实很弱。 所以，从这些角度，会尽量期望在HTML界面层与JavaScript业务逻辑之间，存在一种分离。 这时候，再看看绝大多数界面组件存在什么问题： 有时候我们考虑一下DOM操作的类型，会发现其实是很容易枚举的： 创建并插入节点 移除节点 节点的交换 属性的设置 多数界面组件封装的绝大部分内容不过是这些东西的重复。这些东西，其实是可以通过某些配置描述出来的，比如说，某个数组以什么形式渲染成一个select或者无序列表之类，当数组变动，这些东西也跟着变动，这些都应当被自动处理，如果某个方案在现在这个时代还手动操作这些，那真的是一种落伍。 所以我们可以看到，以Angular，Knockout，Vue，Avalon为代表的框架们在这方面做了很多事，尽管理念有所差异，但大方向都非常一致，也就是把大多数命令式的DOM操作过程简化为一些配置。 有了这种方式之后，我们可以追求不同层级的复用： 业务模型因为是纯逻辑，所以非常容易复用 视图模型基本上也是纯逻辑，界面层多数是纯字符串模板，同一个视图模型搭配不同的界面模板，可以实现视图模型的复用 同一个界面模板与不同的视图模型组合，也能直接组合出完全不同的东西 所以这么一来，我们的复用粒度就非常灵活了。正因为这样，我一直认为Angular这样的框架战略方向是很正确的，虽然有很多战术失误。我们在很多场景下，都是需要这样的高效生产手段的。 6. 组件的长期积累我们做组件化这件事，一定是一种长期打算，为了使得当前的很多东西可以作为一种积累，在将来还能继续使用，或者仅仅作较小的修改就能使用，所以必须考虑对未来标准的兼容。主要需要考虑的方面有这几点： 尽可能中立于语言和框架，使用浏览器的原生特性 逻辑层的模块化（ECMAScript module） 界面层的元素化（Web Components） 之前有很多人对Angular 2.0的激进变更很不认同，但它的变更很大程度上是对标准的全面迎合。这不仅仅是它的问题，其实是所有前端框架的问题。不面对这些问题，不管现在多么好，将来都是死路一条。这个问题的根源是，这几个已有的规范约束了模块化和元素化的推荐方式，并且，如果要对当前和未来两边做适配的话，基本就没法干了，导致以前的都不得不做一定的迁移。 模块化的迁移成本还比较小，无论是之前AMD还是CMD的，都可以根据一些规则转换过来，但组件化的迁移成本太大了，几乎每种框架都会提出自己的理念，然后有不同的组件化理念。 还是从三个典型的东西来说：Polymer，React，Angular。 Polymer中的组件化，其实就是标签化。这里的标签，并不只是界面元素，甚至逻辑组件也可以这样，比如这个代码： 123&lt;my-panel&gt; &lt;core-ajax id="ajax" url="https://url" params="&#123;&#123;formdata&#125;&#125;" method="post"&gt;&lt;/core-ajax&gt;&lt;/my-panel&gt; 注意到这里的core-ajax标签，很明显这已经是纯逻辑的了，在大多数前端框架或者库中，调用ajax肯定不是这样的，但在浏览器端这么干也不是它独创，比如flash里面的WebService，比如早期IE中基于htc实现的webservice.htc等等，都是这么干的。在Polymer中，这类东西称为非可见元素（non-visual-element）。 React的组件化，跟Polymer略有不同，它的界面部分是标签化，但如果有单纯的逻辑，还是纯JavaScript模块。 既然大家的实现方式都那么不一致，那我们怎么搞出尽量可复用的组件呢？问题到最后还是要绕到Web Components上。 在Web Components与前端组件化框架的关系上，我觉得是这么个样子： 各种前端组件化框架应当尽可能以Web Components为基石，它致力于组织这些Components与数据模型之间的关系，而不去关注某个具体Component的内部实现，比如说，一个列表组件，它究竟内部使用什么实现，组件化框架其实是不必关心的，它只应当关注这个组件的数据存取接口。 然后，这些组件化框架再去根据自己的理念，进一步对这些标准Web Components进行封装。换句话说，业务开发人员使用某个组件的时候，他是应当感知不到这个组件内部究竟使用了Web Components，还是直接使用传统方式。（这一点有些理想化，可能并不是那么容易做到，因为我们还要管理像import之类的事情）。 7. 我们需要关注什么目前来看，前端框架/库仍然处于混战期，可比中国历史上的春秋战国，百家齐放，作为跟随者来说，这是很痛苦的，因为无所适从，很可能你作为一个企业的前端架构师或者技术经理，需要做一些选型工作，但选哪个能保证几年后不被淘汰呢？基本没有。 虽然我们不知道将来什么框架会流行，但我们可以从一些细节方面去关注，某个具体的方面，将来会有什么，也可以了解一下在某个具体领域存在什么样的方案。一个完整的框架方案，无非是以下多个方面的综合。 7.1 模块化这块还是不讲了，支付宝seajs还有百度ecomfe这两个团队的人应该都能比我讲得好得多。 7.2 Web Components本文前面讨论过一些，也不深入了。 7.3 变更检测我们知道，现代框架的一个特点是自动化，也就是把原有的一些手动操作提取。在前端编程中，最常见的代码是在干什么呢？读写数据和操作DOM。不少现代的框架/库都对这方面作了处理，比如说通过某种配置的方式，由框架自动添加一些关联，当数据变更的时候，把DOM进行相应修改，又比如，当DOM发生变动的时候，也更新对应的数据。 这个关联过程可能会用到几种技术。首先我们看怎么知道数据在变化，这里面有三种途径： 一、存取器的封装。这个的意思也就是对数据进行一层包装，比如： 123456789var data = &#123; name: "aaa", getName: function() &#123; return this.name; &#125;, setName: function(value) &#123; this.name = value; &#125;&#125; 这样，不允许用户直接调用data.name，而是调用对应的两个函数。Backbone就是通过这样的机制实现数据变动观测的，这种方式适用于几乎所有浏览器，缺点就是比较麻烦，要对每个数据进行包装。 这个机制在稍微新一点的浏览器中，也有另外一种实现方式，那就是defineProperty相关的一些方法，使用更优雅的存取器，这样外界可以不用调用函数，而是直接用data.name这样进行属性的读写。 国产框架avalon使用了这个机制，低版本IE中没有defineProperty，但在低版本IE中不止有JavaScript，还存在VBScript，那里面有存取器，所以他巧妙地使用了VBS做了这么一个兼容封装。 基于存取器的机制还有个麻烦，就是每次动态添加属性，都必须再添加对应的存取器，否则这个属性的变更就无法获取。 二、脏检测。 以Angular 1.x为代表的框架使用了脏检测来获知数据变更，这个机制的大致原理是： 保存数据的新旧值，每当有一些DOM或者网络、定时器之类的事件产生，用这个事件之后的数据去跟之前保存的数据进行比对，如果相同，就不触发界面刷新，否则就刷新。 这个方式的理念是，控制所有可能导致数据变更的来源（也就是各种事件），在他们可能对数据进行操作之后，判断新旧数据是否有变化，忽略所有中间变更，也就是说，如果你在同一个事件中，把某个数据任意修改了很多次，但最后改回来了，框架会认为你什么都没干，也就不会通知界面去刷新了。 不可否认的是，脏检测的效率是比较低的，主要是不能精确获知数据变更的影响，所以当数据量更大的情况下，浪费更严重，需要手动作一些优化。比如说一个很大的数组，生成了一个界面上的列表，当某个项选中的时候，改变颜色。在这种机制下，每次改变这个项的数据状态，就需要把所有的项都跟原来比较一遍，然后，还要再全部比较一次发现没有关联引起的变化了，才能对应刷新界面。 三、观察机制。 在ES7里面，引入了Object的observe方法，可以用于监控对象或数组的变动。 这是目前为止最合理的观测方案。这个机制很精确高效，比如说，连长跟士兵说，你去观察对面那个碉堡里面的动静。这个含义很复杂，包括什么呢？ 是不是加人了 是不是有人离开了 谁跟谁换岗了 上面的旗子从太阳旗换成青天白日了 所谓观察机制，也就是观测对象属性的变更，数组元素的新增，移除，位置变更等等。我们先思考一下界面和数据的绑定，这本来就应当是一个外部的观察，你是数据，我是界面，你点头我微笑，你伸手我打人。这种绑定本来就应当是个松散关系，不应当因为要绑定，需要破坏原有的一些东西，所以很明显更合理。 除了数据的变动可以被观察，DOM也是可以的。但是目前绝大多数双向同步框架都是通过事件的方式把DOM变更同步到数据上。比如说，某个文本框绑定了一个对象的属性，那很可能，框架内部是监控了这个文本框的键盘输入、粘贴等相关事件，然后取值去往对象里写。 这么做可以解决大部分问题，但是如果你直接myInput.value=”111”，这个变更就没法获取了。这个不算大问题，因为在一个双向绑定框架中，一个既被监控，又手工赋值的东西，本身也比较怪，不过也有一些框架会尝试从HTMLInputELement的原型上去覆盖value赋值，尝试把这种东西也纳入框架管辖范围。 另外一个问题，那就是我们只考虑了特定元素的特定属性，可以通过事件获取变更，如何获得更广泛意义上的DOM变更？比如说，一般属性的变更，或者甚至子节点的增删？ DOM4引入了MutationObserver，用于实现这种变更的观测。在DOM和数据之间，是否需要这么复杂的观测与同步机制，目前尚无定论，但在整个前端开发逐步自动化的大趋势下，这也是一种值得尝试的东西。 复杂的关联监控容易导致预期之外的结果： 慕容复要复国，每天读书练武，各种谋划 王语嫣观察到了这种现象，认为表哥不爱自己了 段誉看到神仙姐姐闷闷不乐，每天也茶饭不思 镇南王妃心疼爱子，到处调查这件事的原委，意外发现段正淳还跟旧爱有联系 …… 总之这么下来，最后影响到哪里了都不知道，谁让丘处机路过牛家村呢？ 所以，变更的关联监控是很复杂的一个体系，尤其是其中产生了闭环的时候。搭建整个这么一套东西，需要极其精密的设计，否则熟悉整套机制的人只要用特定场景轻轻一推就倒了。灵智上人虽然武功过人，接连碰到欧阳锋，周伯通，黄药师，全部都是上来就直接被抓了后颈要害，大致就是这意思。 polymer实现了一个observe-js，用于观测数组、对象和路径的变更，有兴趣的可以关注。 在有些框架，比如aurelia中，是混合使用了存取器和观察模式，把存取器作为观察模式的降级方案，在浏览器不支持observe的情况下使用。值得一提的是，在脏检测方式中，变更是合并后批量提交的，这一点常常被另外两种方案的使用者忽视。其实，即使用另外两种方式，也还是需要一个合并与批量提交过程。 怎么理解这个事情呢？数据的绑定，最终都是要体现到界面上的，对于界面来说，其实只关注你每一次操作所带来的数据变更的始终，并不需要关心中间过程。比如说，你写了这么一个循环，放在某个按钮的点击中： 123for (var i=0; i&lt;10000; i++) &#123; obj.a += 1;&#125; 界面有一个东西绑定到这个a，对框架来说，绝对不应当把中间过程直接应用到界面上，以刚才这个例子来说，合理的情况只应当存在一次对界面DOM的赋值，这个值就是对obj.a进行了10000次赋值之后的值。尽管用存取器或者观察模式，发现了对obj上a属性的这10000次赋值过程，这些赋值还是都必须被舍弃，否则就是很可怕的浪费。 React使用虚拟DOM来减少中间的DOM操作浪费，本质跟这个是一样的，界面只应当响应逻辑变更的结束状态，不应当响应中间状态。这样，如果有一个ul，其中的li绑定到一个1000元素的数组，当首次把这个数组绑定到这个ul上的时候，框架内部也是可以优化成一次DOM写入的，类似之前常用的那种DocumentFragment，或者是innerHTML一次写入整个字符串。在这个方面，所有优化良好的框架，内部实现机制都应当类似，在这种方案下，是否使用虚拟DOM，对性能的影响都是很小的。 7.4 Immutable DataImmutable Data是函数式编程中的一个概念，在前端组件化框架中能起到一些很独特的作用。 它的大致理念是，任何一种赋值，都应当被转化成复制，不存在指向同一个地方的引用。比如说： 12345var a = 1;var b = a;b = 2;console.log(a==b); 这个我们都知道，b跟a的内存地址是不一致的，简单类型的赋值会进行复制，所以a跟b不相等。但是： 1234567var a = &#123; counter : 1&#125;;var b = a;b.counter++;console.log(a.counter==b.counter); 这时候因为a和b指向相同的内存地址，所以只要修改了b的counter，a里面的counter也会跟着变。 Immutable Data的理念是，我能不能在这种赋值情况下，直接把原来的a完全复制一份给b，然后以后大家各自变各自的，互相不影响。光凭这么一句话，看不出它的用处，看例子： 对于全组件化的体系，不可避免会出现很多嵌套的组件。嵌套组件是一个很棘手的问题，在很多时候，是不太好处理的。嵌套组件所存在的问题主要在于生命周期的管理和数据的共享，很多已有方案的上下级组件之间都是存在数据共享的，但如果内外层存在共享数据，那么就会破坏组件的独立性，比如下面的一个列表控件： 12345&lt;my-list list-data="&#123;arr&#125;"&gt; &lt;my-listitem&gt;&lt;/my-listitem&gt; &lt;my-listitem&gt;&lt;/my-listitem&gt; &lt;my-listitem&gt;&lt;/my-listitem&gt;&lt;/my-list&gt; 我们在赋值的时候，一般是在外层整体赋值一个类似数组的数据，而不是自己挨个在每个列表项上赋值，不然就很麻烦。但是如果内外层持有相同的引用，对组件的封装性很不利。 比如在刚才这个例子里，假设数据源如下： 12345var arr = [ &#123;name: "Item1"&#125;, &#123;name: "Item2"&#125;, &#123;name: "Item3"&#125;]; 通过类似这样的方式赋值给界面组件，并且由它在内部给每个子组件分别进行数据项的赋值： 1list.data = arr; 赋值之后会有怎样的结果呢？ 1234console.log(list.data == arr);console.log(listitem0.data == arr[0]);console.log(listitem1.data == arr[1]);console.log(listitem2.data == arr[2]); 这种方案里面，后面那几个log输出的结果都会是true，意思就是内层组件与外层共享数据，一旦内层组件对数据进行改变，外层中的也就改变了，这明显是违背组件的封装性的。 所以，有一些方案会引入Immutable Data的概念。在这些方案里，内外层组件的数据是不共享的，它们的引用不同，每个组件实际上是持有了自己的数据，然后引入了自动的赋值机制。 这时候再看看刚才那个例子，就会发现两层的职责很清晰： 外层持有一个类似数组的东西arr，用于形成整个列表，但并不关注每条记录的细节 内层持有某条记录，用于渲染列表项的界面 在整个列表的形成过程中，list组件根据arr的数据长度，实例化若干个listitem，并且把arr中的各条数据赋值给对应的listitem，而这个赋值，就是immutable data起作用的地方，其实是把这条数据复制了一份给里面，而不是把外层这条记录的引用赋值进去。内层组件发现自己的数据改变之后，就去进行对应的渲染 如果arr的条数变更了，外层监控这个数据，并且根据变更类型，添加或者删除某个列表项 如果从外界改变了arr中某一条记录的内容，外层组件并不直接处理，而是给对应的内层进行了一次赋值 如果列表项中的某个操作，改变了自身的值，它首先是把自己持有的数据进行改变，然后，再通过immutable data把数据往外同步一份，这样，外层组件中的数据也就更新了。 所以我们再看这个过程，真是非常清晰明了，而且内外层各司其职，互不干涉。这是非常有利于我们打造一个全组件化的大型Web应用的。各级组件之间存在比较松散的联系，而每个组件的内部则是封闭的，这正是我们所需要的结果。 说到这里，需要再提一个容易混淆的东西，比如下面这个例子： 123&lt;outer-component&gt; &lt;inner-component&gt;&lt;/inner-component&gt;&lt;/outer-component&gt; 如果我们为了给inner-component做一些样式定位之类的事情，很可能在内外层组件之间再加一些额外的布局元素，比如变成这样： 12345&lt;outer-component&gt; &lt;div&gt; &lt;inner-component&gt;&lt;/inner-component&gt; &lt;/div&gt;&lt;/outer-component&gt; 这里中间多了一级div，也可能是若干级元素。如果有用过Angular 1.x的，可能会知道，假如这里面硬造一级作用域，搞个ng-if之类，就可能存在多级作用域的赋值问题。在上面这个例子里，如果在最外层赋值，数据就会是outer -&gt; div -&gt; inner这样，那么，从框架设计的角度，这两次赋值都应当是immutable的吗？ 不是，第一次赋值是非immutable，第二次才需要是，immutable赋值应当仅存在于组件边界上，在组件内部不是特别有必要使用。刚才的例子里，依附于div的那层变量应当还是跟outer组件在同一层面，都属于outer组件的人民内部矛盾。 这里是facebook实现的immutable-js库 7.5 Promise与异步前端一般都习惯于用事件的方式处理异步，但很多时候纯逻辑的“串行化”场景下，这种方式会让逻辑很难阅读。在新的ES规范里，也有yield为代表的各种原生异步处理方案，但是这些方案仍然有很大的理解障碍，流行度有限，很大程度上会一直停留在基础较好的开发人员手中。尤其是在浏览器端，它的受众应该会比node里面还要狭窄。 前端里面，处理连续异步消息的最能被广泛接受的方案是promise，我这里并不讨论它的原理，也不讨论它在业务中的使用，而是要提一下它在组件化框架内部所能起到的作用。 现在已经没有哪个前端组件化框架可以不考虑异步加载问题了，因为，在前端这个领域，加载就是一个绕不过去的坎，必须有了加载，才能有执行过程。每个组件化框架都不能阻止自己的使用者规模膨胀，因此也应当在框架层面提出解决方案。 我们可能会动态配置路由，也可能在动态加载的路由中又引入新的组件，如何控制这些东西的生命周期，值得仔细斟酌，如果在框架层面全异步化，对于编程体验的一致性是有好处的。将各类接口都promise化，能够在可维护性和可扩展性上提供较多便利。 我们之前可能熟知XMLHTTP这样的通信接口，这个东西虽然被广为使用，但是在优雅性等方面，存在一些问题，所以最近出来了替代方案，那就是fetch。 细节可以参见月影翻译的这篇【翻译】这个API很“迷人”——(新的Fetch API) 在不支持的浏览器上，也有github实现的一个polyfill，虽然不全，但可以凑合用window.fetch polyfill 大家可以看到，fetch的接口就是基于promise的，这应当是前端开发人员最容易接受的方案了。 7.6 Isomorphic JavaScript这个东西的意思是前后端同构的JavaScript，也就是说，比如一块界面，可以选择在前端渲染，也可以选择在后端渲染，值得关注，可以解决像seo之类的问题，但现在还不能处理很复杂的状况，持续关注吧。 8. 小结很感谢能看到这里，以上这些是我近一年的一些思考总结。从技术选型的角度看，做大型Web应用的人会很痛苦，因为这是一个青黄不接的年代，目前已有的所有框架/库都存在不同程度的缺陷。当你向未来看去，发现它们都是需要被抛弃，或者被改造的，人最痛苦的是在知道很多东西不好，却又要从中选取一个来用。@严清 跟@寸志 @题叶讨论过这个问题，认为现在这个阶段的技术选型难做，不如等一阵，我完全赞同他们的观点。 选型是难，但是从学习的角度，可真的是挺好的时代，能学的东西太多了，我每天路上都在努力看有可能值得看的东西，可还是看不完，只能努力去跟上时代的步伐。 以下一段，与诸位共勉： It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way–in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用的组件化开发（二）]]></title>
    <url>%2F2017%2F04%2F07%2FWeb%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[管控平台在上一篇中我们提到了组件化的大致思路，这一篇主要讲述在这么做之后，我们需要哪些外围手段去管控整个开发过程。从各种角度看，面对较大规模前端开发团队，都有必要建立这么一个开发阶段的协作平台。 在这个平台上，我们要做哪些事情呢？ 1. HTML片段我们为什么要管理HTML片段？因为有界面要用它们，当这些片段多了之后，需要有个地方来管理起来，可以检索、预览它们，还能看到大致描述。 这应该是整个环节中一个相对很简单的东西，照理说，有目录结构，然后剩下的就是单个的HTML片段文件了，这就可以解决存储和检索的问题了，但我们还要考虑更多。 已有的HTML片段，如何被使用呢？这肯定是一种类似include的方式，通过某种特殊标签（不管是前端还是后端的方式）把这些片段引用进来，这时候就有了第一个问题： 假设有界面A和界面B同时引用了片段C，在某个开发人员修改片段C内容的时候，他如何得知将会影响到界面A和B呢？一个比较勉强的方式是全项目查找，但这在很多情况下是不够的。 如果我们的HTML片段是作为独立的公共库存在的，它已经不能通过项目内查找去解决这一问题了，因为不管A还是B，只要他不处于片段C的项目空间，就无从追寻。 这时候很多人会问两个问题： 跨项目的界面片段重用，意义在哪里？ 如果我们的产品是针对一个小领域，它的复杂度根本不需要划分多个项目部分来协作完成。设想场景是面对很大的行业，各项目都是子产品，将来可能是其中若干个联合部署，这时候，保持其中的一致性是非常重要的。比如我们有个基本配置界面，在多个子产品中都要用，如果各自开发一个，其操作风格很可能就是不一致的，给人的印象就是不专业。所以会需要把常见的界面片段都归集起来，供业务方挑选使用。 修改C，只提供说明，但是不通知A和B，不实时更新他们的版本，然后自行决定怎样升级，如何？ 这会有一个问题，每次有小功能升级的时候，代码是最容易同步合并的，所以才会有“持续集成”这个概念，如果是一直伴随升级，总要比隔一个大阶段才升级好，升级成本应尽量分摊到平时，就像农妇养小猪，小猪每天长一点，每天都抱来抱去，不觉得吃力，即使长大了也还能抱得动。 现在问题就很明确了，一定要有一种方式来把这个依赖关系管理起来，很显然，已有的版本库是肯定管不了这些的，所以只能在外围做一些处理。 我们建立一个管理平台，除了管理实体文件的版本，还管它们之间的关系。具体这个关系如何收集整理，有两种方式：手动配置，代码分析。 手动配置是比较土的方式，开发人员每提交一个文件，就去这系统上手动配置它的依赖关系。代码分析的话，要在每次提交文件的时候解析文件的包含规则，找出确切的文件。这两者各有利弊，前者比较笨，但容易做，后者对代码格式的要求比较高，要考虑的情况较多。 我们的界面往往不是那么简单，HTML片段也可能有层次的，举例来说： 界面A里面包含了片段B，但是片段B自身又包含了片段C，所以这个依赖关系也是有层级的，需要在设计的时候一并考虑。 2. JavaScript模块JavaScript代码的管理，比HTML片段的状况好一些，因为业界很多这方面的解决方案。但它们还是没有解决当依赖项产生变更的时候反向通知的问题。 所以我们还是得像HTML片段一样，把它们的依赖关系都管理到平台里。于是，每个JavaScript模块都显式配置了自己所依赖的其他模块，通过这种单向关系，形成了一套完整的视图。 在JavaScript模块的代码实现中，我们是不提倡直接写依赖关系的。很多通用规范，比如AMD，往往建议我们这样写模块： define([&apos;dep1&apos;, &apos;dep2&apos;], function (dep1, dep2) { var moduleA = function () {}; return moduleA; }); 但我们的系统是面向行业的，比这种通用解决方案要苛刻一些。比如说，如果有一天重构代码，JavaScript模块们调整了目录或者名字，这么写的就痛苦了，他必须把所有影响到的都去调整一遍，这是要搜索替换的。况且，就像上面HTML模板的部分提到的，影响了处于其他项目中依赖它的代码，缺少合适的方式去通知他们修改。 所以我们期望的是，在每个编写的JavaScript模块中只存放具体实现，而把依赖关系放在我们的平台上管理，这样，即使当前模块作了改名之类的重构处理，处于外部项目中依赖它的那些代码也不必修改，下一次版本发布的生成过程会自动把这些事情干掉。 对应到上面的这段代码，我们需要开发人员做的只是其中的实现，也就是moduleA的那个部分，外面这些依赖的壳子，是会在发布阶段根据已配置的依赖关系自动生成的。 如果需要，JavaScript模块还可以细分，比如类似Angular里面那样，把factory，controller和directive分离出来，这会对后续有些处理提供方便。 现在我们有必要讨论一下模块的粒度了，我们这里提到的都是基本的粒度，每个JavaScript模块中存放的应该只有一个很具体东西的实现。那么，有个问题，在我们发布的时候，是不是就按照这个粒度发布出去呢？ 很显然不行，如果这么做，很可能会出现复杂界面一次要用10多个HTTP请求才能加载完它所需要的所有JavaScript代码的情况，所以需要做一些合并。 那么，合并的策略是什么？在我们这个平台上，开发人员又是要怎样定义这个合并关系的呢？我们需要在模块之上定义一个更大粒度的组织方式，这个方式与模块的关系，就好比Java里面，jar文件与class的关系。如果开发人员不显式配置，也可以通过全局策略，比如按最下层目录来合并。 这个时候，在实际使用这些代码的时候，需要带两个配置信息过去，一个是要动态载入的JavaScript文件（合并之后的），二是每个JavaScript文件中包含的原始模块。 3. 单元测试如果JavaScript模块都已经被良好有序管理起来，就可以为它们考虑单元测试的事情了。单元测试对于提高基础单元的可靠度，是有非常重要意义的。 在我们这个平台里，可以把单元测试跟JavaScript模块关联起来，每个JavaScript模块可以挂一组单元测试代码，这些代码可以在线编写，在线运行。 单元测试的本质就是编写模拟代码来调用已有模块，考虑到我们的模块是JavaScript，所以很多思路都倾向于在浏览器端执行它们，对于单个模块的单元测试，这不是个问题。 如果要批量执行整个系统的单元测试，那就不一样了。把JavaScript代码先加载到浏览器中，然后再执行，很多时候并不需要这么复杂。我们完全可以在服务端把它们做了。 借助Node.js的能力，我们可以在服务端执行JavaScript代码，也就意味着能够把绝大多数JavaScript模块的单元测试在服务端就执行掉。当然，我们为此可能要多做不少事情，比如说，有些库需要移植一份node版的，常见的有AJAX调用等等。 注意了，能够在服务端做JavaScript单元测试是有先决条件的，代码的分层必须很良好，除了视图层，其他任何层面都不能操作DOM。所以我们这里主要测试的也正是除了视图层之外的所有JavaScript业务逻辑。至于视图层怎么办？这个真的很难解决，这世界上不是所有东西都能自动做的，只能先把可做的做了，以后再来考虑这些。 4. 文档和示例管理4.1. 文档现在我们有HTML片段和JavaScript模块了，需要给它们多一些描述信息。简单描述显然是不够的，我们还要详细文档。 这种详细文档可以通过某种方式生成，也可以由开发人员手动编写。与传统的离线文档不同，在线的文档更实时，并且，每当一个开发人员变更了他的文档之后，不需要经过全量构建，访问者可以实时访问到他的最新版本。 熟悉GitHub的朋友们可能早已习惯这种方式，在项目库里面存在一些以md格式结尾的文本文件，使用markdown语法来编写一些说明文档。 毫无疑问，这类格式很适合在线协作，所以我们也会在平台上集成这么一种编写文档的方式，无论是针对HTML模板还是JavaScript模块，或者是其他什么类型，甚至还可以用来当博客，就像月影同学的gitpress平台，能直接从GitHub上拉取文本或者HTML文件形成博客。 文档除了以集成的形式浏览之外，应当也可以以单独链接的方式发出去，这时候用户就可以像看一个新闻网页一样去浏览。如果再进一步做下去，还可以做电子书的生成，提供打包的离线文档。 4.2. 示例在编写代码文档的过程中，可能免不了要插入示例，示例有两种形态，一种是纯文本，类似gist这样，一种是可在线运行，类似jsfiddle和jsbin这样。 这两种都有各自的优点，所以可以都做，示例的存放可以与文档类似，也应当能通过一个链接独立运行。 4.3. 幻灯片有时候我们看到一些在线的幻灯片，觉得效果很帅，比如reveal.js，我们的开发人员有时候作代码分析或者走查的时候也不免要写一些演示，如果能把这些东西也随项目管理起来，能在线查看，会是很不错的一件事。所以我们也可以考虑给它们加个存储界面，甚至做个简易的在线编写器。 5. 项目与目录管理说到现在，我们似乎还遗漏了一点什么。那就是以上提到的这些东西，以什么为组织单位来存储？ 考虑到我们的这个平台是要管理一整个大产品的全部前端内容的，它里面应该分了很多项目，对应到子产品上，这么一来，很自然地，项目就成了第一级组织单位。项目之下，没有悬念地，只有目录了。 对于一个项目而言，它有哪些要做的事情呢？首先要能配置其实体存储位置。前面提到的这么多代码、文档之类，最终都是要实体存储的，怎么存？我们当然可以自己搞一套，在文件系统上做起来，但是还要考虑它们的版本管理，非常麻烦，所以不如直接对接某个版本库，调用它的接口去存取文件，这里配置的就是版本库的路径。 其次，要考虑从已有项目复制，类似GitHub里面的fork功能，不过内部处理机制可以略有不同，fork的项目默认未必要有实体文件，只有当产生了修改或者新增操作的时候才创建，剩下的还引用原来的就可以了。我们这里的项目复制功能是为项目化版本而考虑的，经常出现一个产品版本支持多个客户项目的情况，所以可能会用得着这个特性。 然后，也要考虑项目的依赖关系。依赖一个项目，意思是需要用到它里面的组件，所以实质是组件的依赖。提供项目依赖这个视图，只是为了未来变更的一些考虑。 6. 评论管理之前提到，我们整个平台的目的是为了提高大型前端团队的协作能力，协作是离不开交流的。上述的任何功能，都应当带有交流沟通的能力。 比如说，如果开发人员A使用了其他人写的一个代码组件a，对其中一些细节有疑问，他应当可以对它进行评论。在他评论的时候，任何参与维护过这个组件的人员都能收到一个提醒，这时候他可以选择过来看看，回复这个疑问。同理，在文档、示例下也可以如此操作。 在互联网上有这类产品，用于在任意URL下挂接评论交流系统，比较有名的就是Disqus，我们可以看到很多网站下面挂着它，用于做交流评论，这样用户可以用一个账号在多个网站之间交流。国内也有同类的，比如多说，能够用微博、QQ等账号登录进行交流。 从我们这个平台本身看，如果是部署在企业内部作流程提升，引入外部评论系统的可能性就比较小了。因为在企业内部用，一定是希望这个员工的账号信息跟工号挂钩，也能够跟版本服务器账号等模块作集成，权限也便于控制。 从另外一个角度讲，某个人员登录这个系统的时候，他可能收到很多消息，来自不同的代码或文档位置，挨个点过去回复也有些麻烦，我们应当给他提供一个全局视图，让他能在一个统一的界面把这些问题都答复掉，如果他需要的话，也是可以点进去到实际的位置。 7. 用户和权限控制从以上部分我们已经看到，这个系统是一个比较复杂的开发过程管控平台。这样的话，每个使用的人就应当可以登录，然后分配不同的权限等级。 未登录用户应当有一些东西的查看权限，但是不能发表评论。已登录的用户根据权限级别，可以控制能否创建、修改项目，创建、修改目录，代码，单元测试，文档等。 8. 国际化字符串管理一个跨语言区域的Web应用不可避免要跟国际化打交道，这个事情通常是在服务端做，比如通过在界面代码中嵌入类似&lt;% =getRes(key, lan) %&gt;这样的代码，去获取相应的字符串，替换到界面里来。 这个事情是要占用应用服务器资源的，而且国际化本身其实是一个在运行之前就已经确定的事，完全可以把这个过程放在发布阶段就做掉。比如说，我们给每种语言预先就把代码生成多份，只是部署在一起，根据需要的情况来动态加载特定的那一份。 有不少客户端的国际化方案，是把资源文件拆细，以页面为单位存储，但这其实是不太合理的。第一个原因就是在Web2.0时代，“页面”这个概念本身就已经弱化了，到了单页应用里，整个应用都只是一个页面，这个时候，资源文件以什么粒度来组织呢？ 我们提到过，采用MV*框架去做Web应用的架构，有一个目标是做组件化。组件化的意图就是某个组件可以尽可能随心所欲地放在需要的地方用。如果把资源文件的粒度弄小到对应HTML片段和JavaScript模块这一级，灵活性倒是有了，带来的问题就是管理成本增大。 做一个行业应用，最重要的就是业务一致性，这包括逻辑的一致性，也包括了术语的一致性。某一个词，可能在多个资源文件中都出现，这就增加了不一致的可能性。 所以，应当有一个统一的术语管理平台，一切界面上出现的文字或者提示，都必须来自这个平台。 9. 静态资源的管理在发布系统的时候，除了需要发布代码，还需要发布图片等静态资源，这些东西也应当被管理起来。 静态资源在两种情况下可用：随产品发布，在本平台被引用。比如说有一个图片，在这个平台上作了管理，它可以被配置到某个项目上，在发布的时候导出。这个图片还可以被用链接的方式查看或者下载，如果本平台内部的一个文档或者示例要引用它，也是可以的。 10. 样式与主题管理在Web系统里，样式和主题是很重要的一环。样式的管理和发布一直是一个比较复杂的话题，早几年一般都是分块写，然后组合合并，最近这些年有LESS，SASS和Stylus这类技术，解决了编写和发布的分离问题。 我们看看发布的最大问题是什么？是不同部分的合并。为了追求灵活性，不得不把东西拆得很细，之前HTML片段和JavaScript模块的处理方式都是这样。这么做，我们就需要另外一件事：这些细小的东西，尽可能要覆盖全面。 对应到CSS里面，我们要做的是把每种在系统中可能出现的元素、类别都作为单独的规则维护起来，生成一个全局的规则列表。不同项目间，实现可以不同，但规则的名字是固定的，定制只允许修改实现，不允许修改规则。如果要新增之前没有的规则，也必须在全局规则列表里先添加，再作实现。 样式规则被管理之后，可以在界面组件上对它作关联，也可以不做。做的好处是发布的时候能只把用到的那些样式规则生成发布出去，如果能接受每次发布全量CSS，那也无所谓。 除了规则，也需要考虑一些变量的管理，在CSS中合理使用变量，会大为减轻定制化所导致的工作量。 11. 一键发布我们引入了这么一堆东西，其实是增加了发布的复杂度。为什么呢？ 之前不管HTML、JavaScript还是CSS，都是手写出来，最多经过一个minify的工作，就发布了，整个过程很简单，两句脚本搞定。 现在可复杂了，先要分析依赖关系，然后提取文件，然后国际化字符串替换，然后合并，然后代码压缩，整个过程很折腾，不给配置管理员一个解释的话，他一定过来砍人。 我们有个原则：解决问题的过程中，如果引入了新的问题，要求负责解决原问题的人也一起解决掉。现在为了一些意图，增加了版本发布的复杂度，那也要有个办法再把这事摆平，至少不能比原来复杂。 所以我们就要把这些过程都集成到管控平台里，做一个一键发布的过程，把所有的这些操作都集成起来，配置管理员发布版本的时候只要点一下就可以把所有这些事情做掉。甚至说，这些流程还可以配置，能够加减环节。 这时候我们做到了跟之前发版本一样方便，能不能多做点什么呢？ 可以把JavaScript单元测试集成到版本发布阶段。因为我们已经把JavaScript按照职责做了分层，并且把UI部分做了隔离，就可以在浏览器之外把这个单元测试做掉，平时提交代码的时候也可以做，最终在版本发布阶段再全量做一下，也是很有意义的。 代码依赖关系管理的另一个目的是什么呢？是最小化发布，既然我们都管理了文件之间的关系，那么，从根出发，显然是能够得出哪些代码文件在本项目中使用的，就可以每次从我们的全量代码库中取得确切需要的一部分来发布。这也是我们整个管控平台带来的优势。 12. 小结我们这一篇比较复杂，提出了一整套解决大规模前端协作的管控机制。这套理论的本质是在开发和版本发布之间加了一个环节，把Web体系中除了服务之外的一切静态资源都纳入其中，强化了现有主流的一些基于命令行的前端工程化组织模式。 相比于传统行业，比如汽车制造，我们这个环节相当于生产流水线的设计，其中一些组件的存储就类似仓储机制，发布就类似出厂过程。 这个平台本身还有不少其他的可做的东西，比如甚至可以在上面做界面的可视化定制等，这些是长远的终极目标，在后面的文章里会谈谈一些考虑。 后续文章中，我们会展望有了这个平台之后，整个前端的协作流程是怎样的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用的组件化开发（一）]]></title>
    <url>%2F2017%2F03%2F25%2FWeb%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本思路1. 为什么要做组件化？无论前端也好，后端也好，都是整个软件体系的一部分。软件产品也是产品，它的研发过程也必然是有其目的。绝大多数软件产品是追逐利润的，在产品目标确定的情况下，成本有两个途径来优化：减少部署成本，提高开发效率。 减少部署成本的方面，业界研究得非常多，比如近几年很流行的“去IOE”，就是很典型的，从一些费用较高的高性能产品迁移到开源的易替换的产品集群，又比如使用Linux + Mono来部署.net应用，避开Windows Server的费用。 提高开发效率这方面，业界研究得更多，主要途径有两点：加快开发速度，减少变更代价。怎样才能加快开发速度呢？如果我们的开发不是重新造轮子，而是每一次做新产品都可以利用已有的东西，那就会好很多。怎样才能减少变更代价呢？如果我们能够理清模块之间的关系，合理分层，每次变更只需要修改其中某个部分，甚至不需要修改代码，仅仅是改变配置就可以，那就更好了。我们先不看软件行业，来看一下制造行业，比如汽车制造业，他们是怎么造汽车的呢？造汽车之前，先设计，把整个汽车分解为不同部件，比如轮子，引擎，车门，座椅等等，分别生产，最后再组装，所以它的制造过程可以较快。如果一辆汽车轮胎被扎破了，需要送去维修，维修的人也没有在每个地方都修一下，而是只把轮胎拆下来修修就好了，这个轮胎要是实在坏得厉害，就干脆换上个新的，整个过程不需要很多时间。 席德梅尔出过一款很不错的游戏，叫做《文明》（Civilization），在第三代里面，有一项科技研究成功之后，会让工人工作效率加倍，这项科技的名字就叫做：可替换部件（Replacement Parts）。所以，软件行业也应当引入可替换的部件，一般称为组件。 2. 早期的前端怎么做组件化的？在服务端，我们有很多组件化的途径，像J2EE的Beans就是一种。组件建造完成之后，需要引入一些机制来让它们可配置，比如说，工作流引擎，规则引擎，这些引擎用配置的方式组织最基础的组件，把它们串联为业务流程。不管使用什么技术、什么语言，服务端的组件化思路基本没有本质差别，大家是有共识的，具体会有服务、流程、规则、模型等几个层次。 早期展示层基本以静态为主，服务端把界面生成好，浏览器去拿来展示，所以这个时期，有代码控制的东西几乎全在服务端，有分层的，也有不分的。如果做了分层，大致结构就是下图这样： 这个图里，JSP（或者其他什么P，为了举例方便，本文中相关的服务端技术都用Java系的来表示）响应浏览器端的请求，把HTML生成出来，跟相关的JavaScript和CSS一起拿出去展示。注意这里的关键，浏览器端对界面的形态和相关业务逻辑基本都没有控制权，属于别人给什么就展示什么，想要什么要先提申请的尴尬局面。 这个时期的Web开发，前端的逻辑是基本可忽略的，所以前端组件化方式大同小异，无论是ASP还是JSP还是其他什么P，都可以自定义标签，把HTML代码和行间逻辑打包成一个标签，然后使用者直接放置在想要的地方，就可以了。 在这一时代，所谓的组件化，基本都是taglib这样的思路，把某一块界面包括它的业务逻辑一起打成一个端到端的组件，整个非常独立，直接一大块从界面到逻辑都有，而且逻辑基本上都是在服务端控制，大致结构如下图所示。 3. SPA时代，出现了新问题自从Web2.0逐渐流行，Web前端已经不再是纯展示了，它逐渐把以前在C/S里面做的一些东西做到B/S里面来，比如说Google和微软的在线Office，这种复杂度的Web应用如果还用传统那种方式做组件化，很显然是行不通的。 我们看看之前这种组件化的方式，本质是什么？是展现层跟业务逻辑层的隔离，后端在处理业务逻辑，前端纯展现。如果现在还这么划分，就变成了前端有界面和逻辑，后端也有逻辑，这就比较乱了。我们知道，纯逻辑的分层组件化还是比较容易的，任何逻辑如果跟展现混起来，就比较麻烦了，所以我们要把分层的点往前推，推到也能把单独的展现层剥离出来。 如下图所示，因为实际上HTML、CSS、JavaScript这些都逐渐静态化，所以不再需要把它们放在应用服务器上了，我们可以把它们放在专门的高性能静态服务器上，再进一步发展，就可以是CDN（Content Delivery Network，内容分发网络）。前端跟后端的通信，基本都是通过AJAX来，也会有一些其他的比如WebSocket之类，总之尽量少刷新了。 在这张图里面可以看到，真正的前端已经形成了，它跟应用服务器之间形成了天然的隔离，所以也能够很独立地进行一些发展演进。 现在很多Web程序在往SPA（单页面程序，Single Page Application）的方向发展，这类系统通常比较类似传统的C/S程序，交互过程比较复杂，因此它的开发过程也会遇到一些困难。 那为什么大家要做SPA呢？它有很多明显的好处，最核心的优势就是高效。这个高效体现在两个方面：一是对于用户来说，这种方式做出来的东西体验较好，类似传统桌面程序，对于那些需要频繁操作的行业用户，有很大优势。二是运行的效率较高，之前集成一些菜单功能，可能要用iframe的方式引入，但每个iframe要独立引入一些公共文件，服务器文件传输的压力较大，还要初始化自己的一套内存环境，比较浪费，互相之间也不太方便通信，一般要通过postMessage之类的方式去交互。 有了SPA之后，比如一块界面，就可以是一个HTML片段，用AJAX去加载过来处理之后放到界面上。如果有逻辑的JavaScript代码，也可以用require之类的异步加载机制去运行时加载，整体的思路是比较好的。 很多人说，就以这样的需求，用jQuery再加一个异步js加载框架，不是很足够了吗？这两个东西用得好的话，也是能够解决一些问题的，但它们处理的并不是最关键的事情。在Web体系中，展现层是很天然的，因为就是HTML和CSS，如果只从文件隔离的角度，也可以做出一种划分的方式，逻辑放在单独的js文件里，html内部尽量不写js，这就是之前比较主流的前端代码划分方式。 刚才我们提到，SPA开发的过程中会遇到一些困难，这些困难是因为复杂度大为提升，导致了一些问题，有人把这些困难归结为纯界面的复杂度，比如说，控件更复杂了之类，没有这么简单。问题在于什么呢？我打个比方：我们在电脑上开两个资源管理器窗口，浏览到同一个目录，在一个目录里把某个文件删了，你猜猜另外一个里面会不会刷新？ 毫无疑问，也会刷新，但是你看看你用的Web页面，如果把整个复杂系统整合成单页的，能保证对一个数据的更新就实时反馈到所有用它的地方吗？怎么做，是不是很头疼？代码组织的复杂度大为提高，所以需要做一些架构方面的提升。 4. 架构的变更提到架构，我们通常会往设计模式上想。在著名的《设计模式》一书中，刚开始就讲了一种典型的处理客户端开发的场景，那就是MVC。 传统的MVC理念我们并不陌生，因为有Struts，所以在Web领域也有比较经典的MVC架构，这里面的V，就负责了整个前端的渲染，而且是服务端的渲染，也就是输出HTML。如下图所示： 在SPA时代，这已经不合适了，所以浏览器端形成了自己的MVC等层次，这里的V已经变成客户端渲染了，通常会使用一些客户端的HTML模版去实现，而模型和控制器，也相应地在浏览器端形成了。 我们有很多这个层面的框架，比如Backbone，Knockout，Avalon，Angular等，采用了不同的设计思想，有的是MVC，有的是MVP，有的是MVVM，各有其特点。 以Angular为例，它推荐使用双向绑定去实现视图和模型的关联，这么一来，如果不同视图绑定在同一模型上，就解决了刚才所说的问题。而模型本身也通过某种机制，跟其他的逻辑模块进行协作。 这种方式就是依赖注入。依赖注入的核心理念就是通过配置来实例化所依赖的组件。使用这种模式来设计软件架构，会牺牲一些性能，在跟踪调试的便利性等方面也会有所损失，但换来的是无与伦比的松耦合和可替代性。 比如说，这些组件就可以单独测试，然后在用的时候随手引入，毫无压力。对于从事某一领域的企业来说，光这一条就足以吸引他在上面大量投入，把所有不常变动领域模型的业务代码都用此类办法维护起来，这是一种财富。 5. MV*框架的基本原理如果我们来设计Angular这么一个前端框架，应当如何入手呢？很显然，逻辑的控制必须使用JavaScript，一个框架，最本质的事情在于它的逻辑处理方式。 我们的界面为什么可以多姿多彩？因为有HTML和CSS，注意到这两种东西都是配置式的写法，参照后端的依赖注入，如果把这两者视为跟Spring框架中一些XML等同的配置文件，思路就豁然开朗了。 与后端不同的是，充当前端逻辑工具的JavaScript不能做入口，必须挂在HTML里才能运行，所以出现了一个怪异的状况：逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者Hybird的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。好消息是，过了这一步，逻辑层就开始大放异彩了。 从这个时候开始，框架就启动了，它要做哪些事情呢？ 初始化自身（bootstrap） 异步加载可能尚未引入的JavaScript代码（require） 解析定义在HTML上的规则（template parser） 实例化模型（scope） 创建模型和DOM的关联关系（binding, injection） 这些是主线流程，还有一些支线，比如： 解析url的search字符串，恢复状态（route） 加载HTML部件模板（template url） 部件模板和模型的关联（binding） 6. 如何做组件化6.1. HTML的组件化SPA的一个典型特征就是部分加载，界面的部件化也是其中比较重要的一环。界面片段在动态请求得到之后，借助模版引擎之类的技术，经过某种转换，放置到主界面相应的地方。所以，从这个角度来看，HTML的组件化非常容易理解，那就是界面的片段化和模板化。 6.2. JavaScript的组件化JavaScript这个部分有好几个发展阶段。 早期的共享文件，把公共功能的代码提出出来，多个页面共用 动态引用，消灭全局变量 在某些框架上进一步划分，比如Angular里面又分为provider，service，factory，controller JavaScript组件化的目标是什么呢，是清晰的职责，松耦合，便于单元测试和重复利用。这里的松耦合不仅体现在js代码之间，也体现在js跟DOM之间的关系，所以像Angular这样的框架会有directive的概念，把DOM操作限制到这类代码中，其他任何js代码不操作DOM。 如上图所示，总的原则是先分层次，层内再作切分。这么做的话，不再存在之前那种端到端组件了，使用起来没有原先那么方便，但在另外很多方面比较好。 6.3. CSS的组件化这方面，业界也有很多探索，比如LESS，SASS，Stylus等。为什么CSS也要做组件化呢？传统的CSS是一种扁平的文本结构，变更成本较高，比如说想要把结构从松散改紧凑，需要改动很多。如果把实际使用的CSS只当作输出结果，而另外有一种适合变更的方式当作中间过程，这就好多了。比如说，我们把一些东西定义成变量，每个细节元素使用这些变量，当需要整体变更的时候，只需修改这些变量然后重新生成一下就可以了。 以上，我们讨论了大致的Web前端开发的组件化思路，后续将阐述组件化之后的协作过程和管控机制。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建单页Web应用]]></title>
    <url>%2F2017%2F01%2F12%2F%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5Web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[单页应用是什么？让我们先来看几个网站： coding teambition cloud9 注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。 所谓单页应用，指的是在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。它是AJAX技术的进一步升华，把AJAX的无刷新机制发挥到极致，因此能造就与桌面程序媲美的流畅用户体验。 其实单页应用我们并不陌生，很多人写过ExtJS的项目，用它实现的系统，很天然的就已经是单页的了，也有人用jQuery或者其他框架实现过类似的东西。用各种JS框架，甚至不用框架，都是可以实现单页应用的，它只是一种理念。有些框架适用于开发这种系统，如果使用它们，可以得到很多便利。 开发框架ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成整个前端部分，甚至包括布局。随着功能逐渐增加，ExtJS的体积也逐渐增大，即使用于内部系统的开发，有时候也显得笨重了，更不用说开发以上这类运行在互联网上的系统。 jQuery由于偏重DOM操作，它的插件体系又比较松散，所以比ExtJS这个体系更适合开发在公网运行的单页系统，整个解决方案会相对比较轻量、灵活。 但由于jQuery主要面向上层操作，它对代码的组织是缺乏约束的。如何在代码急剧膨胀的情况下控制每个模块的内聚性，并且适当在模块之间产生数据传递与共享，就成为了一种有挑战的事情。 为了解决单页应用规模增大时候的代码逻辑问题，出现了不少MV*框架，他们的基本思路都是在JS层创建模块分层和通信机制。有的是MVC，有的是MVP，有的是MVVM，而且，它们几乎都在这些模式上产生了变异，以适应前端开发的特点。 这类框架包括Backbone，Knockout，AngularJS，Avalon等。 组件化这些在前端做分层的框架推动了代码的组件化，所谓组件化，在传统的Web产品中，更多的指UI组件，但其实组件是一个广泛概念，传统Web产品中UI组件占比高的原因是它的厚度不足，随着客户端代码比例的增加，相当一部分的业务逻辑也前端化，由此催生了很多非界面型组件的出现。 分层带来的一个优势是，每层的职责更专一了，由此，可以对其作单元测试的覆盖，以保证其质量。传统UI层测试最头疼的问题是UI层和逻辑混杂在一起，比如往往会在远程请求的回调中更改DOM，当引入分层之后，这些东西都可以分别被测试，然后再通过场景测试来保证整体流程。 代码隔离与开发传统页面型网站相比，实现单页应用的过程中，有一些比较值得特别关注的点。 从单页应用的特点来看，它比页面型网站更加依赖于JavaScript，而由于页面的单页化，各种子功能的JavaScript代码聚集到了同一个作用域，所以代码的隔离、模块化变得很重要。 在单页应用中，页面模板的使用是很普遍的。很多框架内置了特定的模板，也有的框架需要引入第三方的模板。这种模板是界面片段，我们可以把它们类比成JavaScript模块，它们是另一种类型的组件。 模板也一样有隔离的需要。不隔离模板，会造成什么问题呢？模板间的冲突主要存在于id属性上，如果一个模板中包含固定的id，当它被批量渲染的时候，会造成同一个页面的作用域中出现多个相同id的元素，产生不可预测的后果。因此，我们需要在模板中避免使用id，如果有对DOM的访问需求，应当通过其他选择器来完成。如果一个单页应用的组件化程度非常高，很可能整个应用中都没有元素id的使用。 代码合并与加载策略人们对于单页系统的加载时间容忍度与Web页面不同，如果说他们愿意为购物页面的加载等待3秒，有可能会愿意为单页应用的首次加载等待5-10秒，但在此之后，各种功能的使用应当都比较流畅，所有子功能页面尽量要在1-2秒时间内切换成功，否则他们就会感觉这个系统很慢。 从这些特点来看，我们可以把更多的公共功能放到首次加载，以减小每次加载的载入量，有一些站点甚至把所有的界面和逻辑全部放到首页加载，每次业务界面切换的时候，只产生数据请求，因此它的响应是非常迅速的，比如青云的控制台就是这么做的。 通常在单页应用中，无需像网站型产品一样，为了防止文件加载阻塞渲染，把js放到html后面加载，因为它的界面基本都是动态生成的。 当切换功能的时候，除了产生数据请求，还需要渲染界面，这个新渲染的界面部件一般是界面模板，它从哪里来呢？来源无非是两种，一种是即时请求，像请求数据那样通过AJAX获取过来，另一种是内置于主界面的某些位置，比如script标签或者不可见的textarea中，后者在切换功能的时候速度有优势，但是加重了主页面的负担。 在传统的页面型网站中，页面之间是互相隔离的，因此，如果在页面间存在可复用的代码，一般是提取成单独的文件，并且可能会需要按照每个页面的需求去进行合并。单页应用中，如果总的代码量不大，可以整体打包一次在首页载入，如果大到一定规模，再作运行时加载，加载的粒度可以搞得比较大，不同的块之间没有重复部分。 路由与状态的管理我们最开始看到的几个在线应用，有的是对路由作了管理的，有的没有。 管理路由的目的是什么呢？是为了能减少用户的导航成本。比如说我们有一个功能，经历过多次导航菜单的点击，才呈现出来。如果用户想要把这个功能地址分享给别人，他怎么才能做到呢？ 传统的页面型产品是不存在这个问题的，因为它就是以页面为单位的，也有的时候，服务端路由处理了这一切。但是在单页应用中，这成为了问题，因为我们只有一个页面，界面上的各种功能区块是动态生成的。所以我们要通过对路由的管理，来实现这样的功能。 具体的做法就是把产品功能划分为若干状态，每个状态映射到相应的路由，然后通过pushState这样的机制，动态解析路由，使之与功能界面匹配。 有了路由之后，我们的单页面产品就可以前进后退，就像是在不同页面之间一样。 其实在Web产品之外，早就有了管理路由的技术方案，Adobe Flex中，就会把比如TabNavigator，甚至下拉框的选中状态对应到url上，因为它也是单“页面”的产品模式，需要面对同样的问题。 当产品状态复杂到一定程度的时候，路由又变得很难应用了，因为状态的管理极其麻烦，比如开始的时候我们演示的c9.io在线IDE，它就没法把状态对应到url上。 缓存与本地存储在单页应用的运作机制中，缓存是一个很重要的环节。 由于这类系统的前端部分几乎全是静态文件，所以它能够有机会利用浏览器的缓存机制，而比如动态加载的界面模板，也完全可以做一些自定义的缓存机制，在非首次的请求中直接取缓存的版本，以加快加载速度。 甚至，也出现了一些方案，在动态加载JavaScript代码的同时，把它们也缓存起来。比如Addy Osmani的这个basket.js，就利用了HTML5 localStorage作了js和css文件的缓存。 在单页产品中，业务代码也常常会需要跟本地存储打交道，存储一些临时数据，可以使用localStorage或者localStorageDB来简化自己的业务代码。 服务端通信传统的Web产品通常使用JSONP或者AJAX这样的方式与服务端通信，但在单页Web应用中，有很大一部分采用WebSocket这样的实时通讯方式。 WebSocket与传统基于HTTP的通信机制相比，有很大的优势。它可以让服务端很便利地使用反向推送，前端只响应确实产生业务数据的事件，减少一遍又一遍无意义的AJAX轮询。 由于WebSocket只在比较先进的浏览器上被支持，有一些库提供了在不同浏览器中的兼容方案，比如socket.io，它在不支持WebSocket的浏览器上会降级成使用AJAX或JSONP等方式，对业务代码完全透明、兼容。 内存管理传统的Web页面一般是不需要考虑内存的管理的，因为用户的停留时间相对少，即使出现内存泄漏，可能很快就被刷新页面之类的操作冲掉了，但单页应用是不同的，它的用户很可能会把它开一整天，因此，我们需要对其中的DOM操作、网络连接等部分格外小心。 样式的规划在单页应用中，因为页面的集成度高，所有页面聚集到同一作用域，样式的规划也变得重要了。 样式规划主要是几个方面： 基准样式的分离这里面主要包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式支持。 组件样式的划分这里面是两个层面的规划，首先是各种界面组件及其子元素的样式，其次是一些修饰样式。组件样式应当尽量减少互相依赖，各组件的样式允许冗余。 堆叠次序的管理传统Web页面的特点是元素多，但是层次少，单页应用会有些不同。 在单页应用中，需要提前为各种UI组件规划堆叠次序，也就是z-index，比如说，我们可能会有各种弹出对话框，浮动层，它们可能组合成各种堆叠状态。新的对话框的z-index需要比旧的高，才能确保盖在它上面。诸如此类，都需要我们对这些可能的遮盖作规划，那么，怎样去规划呢？ 了解通信知识的人，应当会知道，不同的频率段被划分给不同的通信方式使用，在一些国家，领空的使用也是有划分的，我们也可以用同样的方式来预先分段，不同类型的组件的z-index落到各自的区间，以避免它们的冲突。 单页应用的产品形态我们在开始的时候提到，存在着很多新型Web产品，使用单页应用的方式构建，但实际上，这类产品不仅仅存在于Web上。点开Chrome商店，我们会发现很多离线应用，这些产品都可以算是单页应用的体现。 除了各种浏览器插件，借助node-webkit这样的外壳平台，我们可以使用Web技术来构建本地应用，产品的主要部分仍然是我们熟悉的单页应用。 单页应用的流行程度正在逐渐增加，大家如果关注了一些初创型互联网企业，会发现其中很大一部分的产品模式是单页化的。这种模式能带给用户流畅的体验，在开发阶段，对JavaScript技能水平要求较高。 单页应用开发过程中，前后端是天然分离的，双方以API为分界。前端作为服务的消费者，后端作为服务的提供者。在此模式下，前端将会推动后端的服务化。当后端不再承担模板渲染、输出页面这样工作的情况下，它可以更专注于所提供的API的实现，而在这样的情况下，Web前端与各种移动终端的地位对等，也逐渐使得后端API不必再为每个端作差异化设计了。 部署模式的改变在现在这个时代，我们已经可以看到一种产品的出现了，那就是“无后端”的Web应用。这是一种什么东西呢？基于这种理念，你的产品很可能只需要自己编写静态Web页面，在某种BaaS（Backend as a Service）云平台上定制服务端API和云存储，集成这个平台提供的SDK，通过AJAX等方式与之打交道，实现注册认证、社交、消息推送、实时通信、云存储等功能。 我们观察一下这种模式，会发现前后端的部署已经完全分离了，前端代码完全静态化，这意味着可以把它们放置到CDN上，访问将大大地加速，而服务端托管在BaaS云上，开发者也不必去关注一些部署方面的繁琐细节。 假设你是一名创业者，正在做的是一种实时协同的单页产品，可以在云平台上，快速定制后端服务，把绝大部分宝贵的时间花在开发产品本身上。 单页应用的缺陷单页应用最根本的缺陷就是不利于SEO，因为界面的绝大部分都是动态生成的，所以搜索引擎很不容易索引它。 产品单页化带来的挑战一个产品想要单页化，首先是它必须适合单页的形态。其次，在这个过程中，对开发模式会产生一些变更，对开发技能也会有一些要求。 开发者的JavaScript技能必须过关，同时需要对组件化、设计模式有所认识，他所面对的不再是一个简单的页面，而是一个运行在浏览器环境中的桌面软件。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从HTML Components的衰落看Web Components的危机]]></title>
    <url>%2F2016%2F11%2F15%2F%E4%BB%8EHTML%20Components%E7%9A%84%E8%A1%B0%E8%90%BD%E7%9C%8BWeb%20Components%E7%9A%84%E5%8D%B1%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[搞前端时间比较长的同学都会知道一个东西，那就是HTC（HTML Components），这个东西名字很现在流行的Web Components很像，但却是不同的两个东西，它们的思路有很多相似点，但是前者已是昨日黄花，后者方兴未艾，是什么造成了它们的这种差距呢？ HTML Components的一些特性因为主流浏览器里面只有IE支持过HTC，所以很多人潜意识都认为它不标准，但其实它也是有标准文档的，而且到现在还有链接，注意它的时间！ http://www.w3.org/TR/NOTE-HTMLComponents 我们来看看它主要能做什么呢？ 它可以以两种方式被引入到HTML页面中，一种是作为“行为”被附加到元素，使用CSS引入，一种是作为“组件”，扩展HTML的标签体系。 行为行为（Behavior）是在IE5中引入的一个概念，主要是为了做文档结构和行为的分离，把行为通过类似样式的方式隔离出去，详细介绍在这里可以看： http://msdn.microsoft.com/en-us/library/ms531079(v=vs.85).aspx.aspx) 行为里可以引入HTC文件，刚才的HTC规范里就有，我们把它摘录出来，能看得清楚一些： engine.htc12345678910111213&lt;HTML xmlns:PUBLIC="urn:HTMLComponent"&gt;&lt;PUBLIC:EVENT NAME="onResultChange" ID="eventOnResultChange" /&gt;&lt;SCRIPT LANGUAGE="JScript"&gt;function doCalc()&#123; : oEvent = createEventObject(); oEvent.result = sResult; eventOnResultChange.fire (oEvent);&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;HTML xmlns:LK="urn:com.microsoft.htc.samples.calc"&gt;&lt;HEAD&gt;&lt;STYLE&gt; LK\:CALC &#123; behavior:url(engine.htc); &#125;&lt;/STYLE&gt;&lt;/HEAD&gt;&lt;LK:CALC ID="myCalc" onResultChange="resultWindow.innerText=window.event.result"&gt;&lt;TABLE&gt;&lt;TR&gt;&lt;DIV ID="resultWindow" STYLE="border: '.025cm solid gray'" ALIGN=RIGHT&gt;0.&lt;/DIV&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 7 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 8 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 9 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" / "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" C "&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 4 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 5 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 6 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" * "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" % " DISABLED&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 1 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 2 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 3 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" - "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE="1/x" DISABLED&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" 0 "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE="+/-"&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" . "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" + "&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=BUTTON VALUE=" = "&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/LK:CALC&gt;&lt;/HTML&gt; 这是一个计算器的例子，我们先大致看一下代码结构，是不是很清晰？再看看现在用jQuery，我们是怎么实现这种东西的：是用选择器选择这些按钮，然后添加事件处理函数。注意你多了一步选择的过程，而且，整个过程混杂了声明式和命令式两种代码风格。如果按照它这样，你所有的JS基本都丢在了隔离的不相关的文件中，整个是一个配置的过程，分离得很干净。 除了这种计算器，还有规范文档中举例的改变界面展示，或者添加动画之类，注意它们的切入点，都是相当于附加在特定选中元素上的行为，即使DOM不给JS暴露任何选择器，也毫无影响，因为它们直接就通过CSS的选择器挂到元素上了。 这种在现在看来，意义不算明显，现在广为使用的先选择元素再添加事件，也是不错的展现和行为分离方式。 但另外一种使用方式就不同了。 组件狭义的HTML5给我们带来了什么？是很多新增的元素标签，比如section，nav，acticle，那这些东西跟原先直接用div实现的，好处在哪里呢？在于语义化。 所谓语义化，就是一个元素能清晰表达自己是干什么的，不会让人有歧义，像div那种，可以类比成是一个Object，它不具体表示什么东西，但可以当成各种东西来用。而nav一写，就知道，它是导航，它就像有class定义的一个实体类，能表达具体含义。 那么，原有的HTML元素显然是不够的，因为实际开发过程中要表达的东西显然远远超出这些元素，比如日历，这种东西就没有一个元素用来描述它，更不用说在一些企业应用中可能会出现的树之类复杂控件了。 不提供原生元素，对开发造成的困扰是代码写起来麻烦，具体可以看前端大神徐飞在知乎的一个回复，第三点： http://www.zhihu.com/question/22426434/answer/21433867 所以，大家都想办法去提供自己的扩充元素的方式，现在我们是知道典型的有angularjs，polymer，但很早的时候也不是没有啊： http://msdn.microsoft.com/en-us/library/ms531076(v=vs.85).aspx.aspx) 看，这就是HTC的添加自定义元素的方式，每个元素可以定义自己对外提供的属性、方法，还有事件，自己内部可以像写一个新页面一样，专注于实现功能。而且你发现没有，它考虑得很长远，提供了命名空间，防止你在一个页面引入两个不同组织提供的同名自定义元素。 这个东西就可以称为组件了，它跟外界是完全隔离的，外界只要把它拿来就可以用，就像用原生元素一样，用选择器选择，设置属性，调用方法，添加事件处理等等，而且，注意到没有，它的属性是带get和set的，这是多么梦寐以求的东西！ 正是因为它这么好用，所以在那个时代，我们用它干了很多东西，封装了各种基础控件，比如树，数据表格，日期选择，等等，甚至当时也有人嫌弃浏览器原生select和radio不好看，用这么个东西，里面封装了图片来模拟功能，替换原生的来用。 当时也有人，比如我在04年就想过，能不能把这些扩大化，扩展到除了基础控件之外的地方，把业务的组件也这么搞一下，一切皆组件，多好？ 但有些事情我直到后来很久以后才想明白，基于业务的端到端组件虽然写起来很方便，却是有致命缺陷的。 到这里为止，对HTML Components的回顾告一段落，也不讨论它为什么就没了之类，这里面争议太大，我只想谈谈从这里面，能看到Web Components这么个大家寄予厚望的新标准需要面对一些什么问题。 Web Components的挑战以下逐条列出，挨个说明，有的已经有了，有的差一些，有的没有，不管这么多，总之谈谈我心目中的这个东西应当是怎样的。 自定义元素标签支持命名空间原因我前面已经说了，可能会有不同组织实现同类功能的组件，存在于同一个页面内，引起命名歧义，所以我想了很久，还是觉得有前缀比较好： 12&lt;yours:ComponentA&gt;&lt;/yours:ComponentA&gt;&lt;his:ComponentA&gt;&lt;/his:ComponentA&gt; 甚至，这里的前缀还可以是个简称别名，比如yours=com.aaa.productA，这可能只有复杂到一定程度才会出现，大家不要以为这太夸张，但总有一天Web体系能构建超大型软件，到那时候你就知道是不是可能了。 样式的局部作用域这个前一段时间有的浏览器实现过，在组件内部，style上加一个scoped属性，这是正确的方向。为什么要这么干呢，所谓组件，引入成本越小越好，在无约定的情况下都能引入，不造成问题，那是最佳的结果。 如果你一个组件的样式不是局部的，很可能就跟主界面的冲突了，就算你不跟主界面的冲突，怎么保证不跟主界面中包含的其他组件的样式冲突？靠命名约定是不现实的，看长远一些，等你的系统够大，这就是大问题了。 跟主文档的通讯一个自定义组件，应当能够跟主文档进行通讯，这个过程包括两个方向，分别可以有多种不同的方式。 从内向外除了事件，真没有什么好办法可以做这个方向的通讯，但事件也可以有两种定义方式，一种是类似onclick那种，主文档应当能够在它上面直接添加对应的事件监听函数，就像对原生元素那样，每个事件都能单独使用。另一种是像postMessage那样，只提供一个通道，具体怎么处理，自己去定义消息格式和处理方式。 这两种实现方式都可行，后者比较偷懒，但也够用了，前者也没有明显优势。 从外向内这个也可以有两种方式，一种是组件对外暴露属性或者方法，让主文档调用，一种是外部也通过postMessage往里传。前者用起来会比较方便，后者也能凑合用用。 所以，如果特别偷懒，这个组件就变得像一个iframe那样，跟外部基本都通过postMessage交互。 JavaScript写到这里我是很纠结的，因为终于来到争议最大的地方了。按照很多人的思路，我这里应该也写隔离成局部作用域的JavaScript才对，但真不行，我们可以先假设组件内部的所有JavaScript都跑在局部作用域，它不能访问主文档中的对象。 我这里解释一下之前那个坑，为什么端到端组件是有缺陷的。 先解释什么叫端到端组件。比如说，我有这么一个组件，它封装了对后端某接口的调用，还有自身的一些展示处理，跟外界通过事件通信。它整个是不需要依赖别人的，初始加载数据都是自己内部做，别人要用它也很简单，直接拿来放在页面里就可以了。 照理说，这东西应当非常好才对，使用起来这么方便，到底哪里不对？我来举个场景。 在页面上同时存在这个组件的多个实例，每个组件都去加载了初始数据，假设它们是不带参数的，每个组件加载的数据都一样，这里是不是就有浪费的请求了？有人可能觉得一点点浪费不算问题，那么继续。 假设这个组件就是一个很普通的下拉列表，用于选取人员的职业，初始可能有医生，教师，警察等等，我把这个组件直接放在界面上，它一出现，就自己去加载了所需的列表信息并且展示了。有另外一个配置界面，用于配置这些职业信息，这时候我在里面添加了一个护士，并且提交了。假设为了数据一致性，我们把这个变更推回到页面，麻烦就出现了。 界面只有一个职业下拉列表的时候可能还好办，有多个的时候，这个更新的策略就有问题了。 如果在组件的内部做这个推送的对接，就会出现要推送多份一致的数据给组件的不同实例的问题。如果把这个放在外面，那我们也有两种方式： 订阅发布模式，组件订阅某个数据源，数据源跟服务端对接，当数据变更的时候，发给每个订阅者 观察者模式，组件观察某个数据源，当数据变更的时候，去取回来 这两种很类似，不管哪种，都面临一个问题： 数据源放在哪？ 很明显不能放在组件内部了，只能放在某个“全局”的地方，但刚才我们假设的是，组件内部的JavaScript代码不能访问外界的对象，所以…… 但要是让它能访问，组件的隔离机制等于白搭。最好的方式，也许是两种都支持，默认是局部作用域，另外专门有一个作用域放给JS框架之类的东西用，但浏览器实现的难度可能就大了不少。 可能有人会说，你怎么把问题搞这么复杂，用这么BT的场景来给我们美好的未来出难题。我觉得问题总是要面对的，能在做出来之前就面对问题，结果应该会好一些。 我注意观察了很多朋友对Web Components的态度，大部分都是完全叫好，但其中有一部分，主要是搞前端MV*的同学对它的态度很保守，主要原因应该是我说的这几点。因为这个群体主要都在做单页型的应用，这个里面会遇到的问题是跟传统前端不同的。 那么，比如Angular，或者React，它们跟Web Components的协作点在哪里呢？我个人觉得是把引擎保留下来，上层部分逐步跟Web Components融合，所以它们不是谁吃掉谁的问题，而是怎样去融合。最终就是在前端有两层，一层是数据和业务逻辑层，一层是偏UI的，在那个层里面，可以存在像Web Components那样的垂直切分，这样会很适宜。 最后说说自己对Polymer的意见，我的看法没有@司徒正美 那么粗暴，但我是认同他的观点的，因为Polymer的根本理念就是在做端到端组件，它会面临很多的挑战。虽然它是一个组件化框架，组件化最适宜于解决大规模协作问题，但是如果是以走向大型单页应用这条路来看，它比Angular和React离目标的距离还远很多。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端MV*框架的意义]]></title>
    <url>%2F2016%2F09%2F05%2F%E5%89%8D%E7%AB%AFMV-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[经常有人质疑，在前端搞MV有什么意义？也有人提出这样的疑问：以AngularJS，Knockout，BackBone为代表的MV框架，它跟jQuery这样的框架有什么区别？我jQuery用得好好的，有什么必要再引入这种框架？ 回答这些问题之前，先要理清一些历史，前端从什么时候开始有框架的？ 早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，这个时期每个界面上只有很少的JavaScript逻辑，基本不太需要框架。随着AJAX的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了，以jQuery为代表，针对界面上常见的DOM操作，远程请求，数据处理等作了封装，也有专注于处理数据的Underscore，严格来说，这些都不能算框架，而是算库。 库和框架是有一些区别的：库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构。框架则是面向一个领域，提供一套解决方案，如果你用我，就得按照我的方式办事。按照这个定义，jQuery和Underscore都只能算是库，ExtJS和dojo算框架。 MV*框架又是为什么兴起的呢？它的出现，伴随着一些Web产品逐渐往应用方向发展，遇到了在C/S领域相同的问题：由于前端功能的增强、代码的膨胀，导致不得不做“前端的架构”这个事情了。很多做后端开发的人对前端架构很不屑，认为前端只是很薄的一层东西，做架构干什么？什么，不但要搞架构，还要搞MVC？Java Struts的MVC中，整个前端都只能算是View而已，你还要在这个View里面划分模型和控制器等其他东西？他们中的多数对这个很不屑，但Web前端随着复杂度的增加，很多地方跟客户端已经没有本质区别了。 jQuery的思维方式是：以DOM操作为中心MV*框架的思维方式是：以模型为中心，DOM操作只是附加 所以回到那个问题上，jQuery满足了你的业务需要，你还有什么必要引入MV*框架？ 这个是要看产品类型的，如果是页面型产品，多数确实不太需要它，因为页面中的JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。 长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。在以往的经验里，他们是有做MVC的，也尝试做了一些界面组件，但做法比较过时，比如说使用JSF或者GWT这样的方式。 JSF的问题是什么？它的问题并不在于界面跟逻辑混合，所谓的纵向切分组件，Polymer这种纯前端框架也是这么切分的，它问题在于组件的生成和渲染不在同一个地方。所以，逻辑代码的位置很尴尬，如果这个界面简单还好说，复杂起来就很麻烦了，就是很多明明是前端逻辑代码，却需要通过后端去生成。 GWT这种方式相对要好一些，它的问题是留给UI调节的余地太小了，比较缺乏灵活性。 这类基于某种服务端技术的组件化方式有一些局限性，比如它较大程度限制了前端的发挥，在早一些的时候，这种方式可能还不错，但是现在随着时代发展，用户对前端用户体验要求越来越高，需要我们把很大一部分精力继续放回前端来。JSF等方案的另外一个问题是绑定了某种服务端环境，很难切换到另外一种后端上，如果碰上要用Hybird方式开发，想复用一些前端逻辑，几乎毫无可能。 那么，我们看看纯前端的框架，看看都是怎么解决这些问题的。以Google为例，它推出了两个框架，Polymer和Angular，而且处于并行发展的阶段，这两者理念还有不小的差别，给不少人带来了困惑。 Polymer切分组件的方式有点类似JSF，它跟HTML5标准中的Shadow DOM和Element有很大联系，这种切分组件的方式非常直观，每个组件都是端到端的，包含UI和逻辑，直接放置到某个界面上就能用，这种方式很容易被业务开发人员接受，但里面的时序比较难处理。 比如说，有两个组件，里面各包含一个下拉框，有数据的联动关系，因为它们处在两个不同的组件里，联动的处理代码就很难写，考虑到组件的特点，要尽量隐藏自己的内部实现，所以从外部获取组件内部的某个元素要绕一层，而组件不能依赖其他外部的东西，所以到最后只有通过事件去实现，这个联动代码写好了应当放在哪里，也是个大问题。我们的例子仅仅是这么简单，就要绕这么个大圈子才能保证时序，如果场景比较复杂，非常难以控制。 如果同样的组件在某个界面被复用多次，数据的一致性也很难保证，设想一下某个界面存在两个一样的下拉框，分别处于不同组件中，两者的数据都需要分别去加载，这个过程是有浪费的，更严重的是，如果这个下拉框对应的数据有更新，很难把每个实例都更新一遍，这个处理过程是非常麻烦的。 Angular框架处理问题的方式跟它有所不同，它是水平分层，所有这些数据访问逻辑都跟UI彻底分离，所以可以很轻松地把这个逻辑代码写出来，这么一来，前面所述端到端的组件就彻底退化，变成只有界面展现了。 看看刚才碰到的两个问题，第一个，模型代码按照业务领域进行划分，获取的数据放在两个不同的数组，然后通过双向绑定跟UI产生关联，如果UI上一个下拉框选中项发生变更，只需要监控这个取值项，然后更新另一个下拉框的取值列表即可，完全不需要绕弯子。即使这两个处于不同模型中，也可以用类似后端的方式，采用事件总线等机制去完成通信。 第二个更简单了，复用的组件其实只有UI，也就是说，只有UI是多实例的，模型其实只有一份，比如说一个地区的树形结构，即使一个界面上同时有维护和使用两种功能，都可以共享同一份模型，当维护这边对数据进行了更新，就实时反馈到模型中，然后由双向绑定再把这个模型同步到界面上的使用方去，整个过程清晰可控。 从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的MV框架，这个状况会大有改观。MV框架的理念是把前端按照职责分层，每一层都相对比较独立，有自己的价值，也有各自发挥的余地。 为什么多数做互联网前端开发的同学们感受不到MV*框架的重要性呢，因为在这个协作体系里，Model的这一块不够复杂，在传统软件领域，Model的部分是代码最多的，View的相对少一些，而互联网领域里，基本是相反的，所以Model这块沦为附加，如果主要在操作View和Controller，那当然jQuery这类框架比较好用了。 所以，经常看到有互联网产品的同学们讲前端MVC，但举例的时候，都比较牵强，很多时候，他们举出来的那个Model，其实都不能算真正的Model，而是在操作View的过程中一些辅助的模型，真正的Model是贯穿前后端的。 归根结底，前端MV*框架带来的是一整套工作流程的变更，后端工程师也可以编写前端的模型代码，把它跟后端彻底打通，交互工程师处理UI跟模型的互动关系，UI工作人员可以专注、无障碍地处理HTML源码，把它们以界面模版的形式提供给交互工程师。这一整套协作机制能够大大提高B/S架构系统的开发效率，如果再有外围的管控平台，生产效率将真正踏进工业化的阶段。 到这个阶段，前端开发人员的出路是什么呢？我认为有两种。拿服装行业来对比，如果你要的是普通的，就使用工业手段批量生产，使用MV*框架，做好架构和组件重用，做得快，细节不是很讲究。如果你想要更好的，有特色的，就需要名家设计，手工打造，非常精巧，高端大气上档次。所以，这也就代表着前端开发的两种发展方向。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始编写自己的JavaScript框架（二）]]></title>
    <url>%2F2016%2F06%2F09%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2. 数据绑定2.1 数据绑定的原理数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。 在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。 先看数据到界面上的的绑定，比如： &lt;input vm-value=&quot;name&quot;/&gt; var person = { name: &quot;Tom&quot; }; 如果我们给name重新赋值，person.name = “Jerry”，怎么才能让界面得到变更？从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如： var person = { name: &quot;Tom&quot;, setName: function(newName) { this.name = newName; //do something } }; 这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做： var person = { name: &quot;Tom&quot;, gender: 5 set: function(key, value) { this[key] = value; //do something } }; 或者合并两个方法，只判断是否传了参数： Person.prototype.name = function(value) { if (arguments.length == 0) { return this._name; } else { this._name = value; } } 这种情况下，赋值的时候就是person.name(“Tom”)，取值的时候就是var name = person.name()了。 有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。 在C#等一些语言里，有一种东西叫做存取器，比如说： class Person { private string name; public string Name { get { return name; } set { name = value; } } } 用的时候，person.Name = “Jerry”，就会调用到set里，相当于是个方法。 这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说： var person = {}; // Add an accessor property to the object. Object.defineProperty(person, &quot;name&quot;, { set: function (value) { this._name = value; //do something }, get: function () { return this._name; }, enumerable: true, configurable: true }); 赋值的时候，person.name = “Tom”，取值的时候，var name = person.name，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。 现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。 再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。 2.2 数据绑定的实现我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。 function parseElement(element) { for (var i=0; i&lt;element.attributes.length; i++) { parseAttribute(element.attributes[i]); } for (var i=0; i&lt;element.children.length; i++) { parseElement(element.children[i]); } } 但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？ 我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。 因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。 thin.define(&quot;Person&quot;, [], function() { function Person() { this.name = &quot;Tom&quot;; this.age = 5; } Person.prototype = { growUp: function() { this.age++; } }; return Person; }); 模型方面都准备好了，现在来看界面： &lt;div vm-model=&quot;Person&quot;&gt; &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt; &lt;/div&gt; 为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。 好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？ 当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样： function parseElement(element, vm) { var model = vm; if (element.getAttribute(&quot;vm-model&quot;)) { model = bindModel(element.getAttribute(&quot;vm-model&quot;)); } for (var i=0; i&lt;element.attributes.length; i++) { parseAttribute(element, element.attributes[i], model); } for (var i=0; i&lt;element.children.length; i++) { parseElement(element.children[i], model); } } 看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。 function bindModel(modelName) { thin.log(&quot;model&quot; + modelName); var model = thin.use(modelName, true); var instance = new model(); return instance; } 现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的： init，用于绑定初始化方法 click，用于绑定点击 value，绑定变量 enable和disable，绑定可用状态 visible和invisible，绑定可见状态 然后就可以实现我们parseAttribute函数了： function parseAttribute(element, attr, model) { if (attr.name.indexOf(&quot;vm-&quot;) == 0) { var type = attr.name.slice(3); switch (type) { case &quot;init&quot;: bindInit(element, attr.value, model); break; case &quot;value&quot;: bindValue(element, attr.value, model); break; case &quot;click&quot;: bindClick(element, attr.value, model); break; case &quot;enable&quot;: bindEnable(element, attr.value, model, true); break; case &quot;disable&quot;: bindEnable(element, attr.value, model, false); break; case &quot;visible&quot;: bindVisible(element, attr.value, model, true); break; case &quot;invisible&quot;: bindVisible(element, attr.value, model, false); break; case &quot;element&quot;: model[attr.value] = element; break; } } } 注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。 这么多绑定，不打算都讲，用bindValue函数来说明一下吧： function bindValue(element, key, vm) { thin.log(&quot;binding value: &quot; + key); vm.$watch(key, function (value, oldValue) { element.value = value || &quot;&quot;; }); element.onkeyup = function () { vm[key] = element.value; }; element.onpaste = function () { vm[key] = element.value; }; } 我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。 在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。 接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。 然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。 var Binder = { $watch: function (key, watcher) { if (!this.$watchers[key]) { this.$watchers[key] = { value: this[key], list: [] }; Object.defineProperty(this, key, { set: function (val) { var oldValue = this.$watchers[key].value; this.$watchers[key].value = val; for (var i = 0; i &lt; this.$watchers[key].list.length; i++) { this.$watchers[key].list[i](val, oldValue); } }, get: function () { return this.$watchers[key].value; } }); } this.$watchers[key].list.push(watcher); } }; 但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。 function bindModel(name) { thin.log(&quot;binding model: &quot; + name); var model = thin.use(name, true); var instance = new model().extend(Binder); instance.$watchers = {}; return instance; } 看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？ 先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。 同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。 嗯，我们是不是可以试一下了？来写个代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Simple binding demo&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;binding&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;xu.fei@outlook.com&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/thin.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div vm-model=&quot;test.Person&quot;&gt; &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt; &lt;/div&gt; &lt;div vm-model=&quot;test.Person&quot; vm-init=&quot;init&quot;&gt; &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt; &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; thin.define(&quot;test.Person&quot;, [], function () { function Person() { this.name = &quot;Tom&quot;; this.age = 5; } Person.prototype = { init: function () { this.name = &quot;Jerry&quot;; this.age = 3; }, growUp: function () { this.age++; } }; return Person; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。 2.3 小结到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。 注意Object.defineProperty仅在Chrome等浏览器中可用，IE需要9以上才比较正常。在司徒正美的avalon框架中，巧妙使用VBScript绕过这一限制，利用vbs的property和两种语言的互通，实现了低版本IE的兼容。我们这个框架的目标不是兼容，而是为了说明原理，所以感兴趣的朋友可以去看看avalon的源码。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始编写自己的JavaScript框架（一）]]></title>
    <url>%2F2016%2F05%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 模块的定义和加载1.1 模块的定义一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。 先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？ 我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。 考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？ 在很多传统高级语言里，变量作用域的边界是大括号，在{}里面定义的变量，作用域不会传到外面去，但我们的JavaScript大人不是这样的，他的边界是function。所以我们这段代码，i仍然能打出值： for (var i=0; i&lt;5; i++) { //do something } alert(i); 那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。 我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过：C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！”Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！”C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！ 啊，我们发现了什么，既然无法避免全局的作用域，那与其让100个function都全局，不如只让一个来全局，其他的都由它管理。 本来我们打算自己当上帝的，现在只好改行先当个工商局长。你想开店吗？先来注册，不然封杀你！于是良民们纷纷来注册。店名叫什么，从哪进货，卖什么的，一一登记在案，为了方便下面的讨论，我们连进货的过程都让工商局管理起来。 店名，指的就是这里的模块名，从哪里进货，代表它依赖什么其他模块，卖什么，表示它对外提供一些什么特性。 好了，考虑到我们的这个注册管理机构是个全局作用域，我们还得把它挂在window上作为属性，然后再用一个function隔离出来，要不然，别人也定义一个同名的，就把我们覆盖掉了。 (function() { window.thin = { define: function(name, dependencies, factory) { //register a module } }; })(); 在这个module方法内部，应当怎么去实现呢？我们的module应当有一个地方存储，但存储是要在工商局内部的，不是随便什么人都可以看到的，所以，这个存储结构也放在工商局同样的作用域里。 用什么结构去存储呢？工商局备案的时候，店名不能跟已有的重复，所以我们发现这是用map的很好场景，考虑到JavaScript语言层面没有map，我们弄个Object来存。 (function() { var moduleMap = {}; window.thin = { define: function(name, dependencies, factory) { if (!moduleMap[name]) { var module = { name: name, dependencies: dependencies, factory: factory }; moduleMap[name] = module; } return moduleMap[name]; } }; })(); 现在，模块的存储结构就搞好了。 1.2 模块的使用存的部分搞好了，我们来看看怎么取。现在来了一个商家，卖木器的，他需要从一个卖钉子的那边进货，卖钉子的已经来注册过了，现在要让这个木器厂能买到钉子。现在的问题是，两个商家处于不同的作用域，也就是说，它们互相不可见，那通过什么方式，我们才能让他们产生调用关系呢？ 个人解决不了的问题还是得靠政府，有困难要坚决克服，没有困难就制造困难来克服。现在困难有了，该克服了。商家说，我能不能给你我的进货名单，你帮我查一下它们在哪家店，然后告诉我？这么简单的要求当然一口答应下来，但是采用什么方式传递给你呢？这可犯难了。 我们参考AngularJS框架，写了一个类似的代码： thin.define(&quot;A&quot;, [], function() { //module A }); thin.define(&quot;B&quot;, [&quot;A&quot;], function(A) { //module B var a = new A(); }); 看这段代码特别在哪里呢？模块A的定义，毫无特别之处，主要看模块B。它在依赖关系里写了一个字符串的A，然后在工厂方法的形参写了一个真真切切的A类型。嗯？这个有些奇怪啊，你的A类型要怎么传递过来呢？其实是很简单的，因为我们声明了依赖项的数组，所以可以从依赖项，挨个得到对应的工厂方法，然后创建实例，传进来。 use: function(name) { var module = moduleMap[name]; if (!module.entity) { var args = []; for (var i=0; i&lt;module.dependencies.length; i++) { if (moduleMap[module.dependencies[i]].entity) { args.push(moduleMap[module.dependencies[i]].entity); } else { args.push(this.use(module.dependencies[i])); } } module.entity = module.factory.apply(noop, args); } return module.entity; } 我们可以看到，这里面递归获取了依赖项，然后当作参数，用这个模块的工厂方法来实例化了一下。这里我们多做了一个判断，如果模块工厂已经执行过，就缓存在entity属性上，不需要每次都创建。以此类推，假如一个模块有多个依赖项，也可以用类似的方式写，毫无压力： thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(A, B, C) { //module D var a = new A(); var b = new B(); var c = new C(); }); 注意了，D模块的工厂，实参的名称未必就要是跟依赖项一致，比如，以后我们代码较多，可以给依赖项和模块名称加命名空间，可能变成这样： thin.define(&quot;foo.D&quot;, [&quot;foo.A&quot;, &quot;foo.B&quot;, &quot;foo.C&quot;], function(A, B, C) { //module D var a = new A(); var b = new B(); var c = new C(); }); 这段代码仍然可以正常运行。我们来做另外一个测试，改变形参的顺序： thin.define(&quot;A&quot;, [], function() { return &quot;a&quot;; }); thin.define(&quot;B&quot;, [], function() { return &quot;b&quot;; }); thin.define(&quot;C&quot;, [], function() { return &quot;c&quot;; }); thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(B, A, C) { return B + A + C; }); var D = thin.use(&quot;D&quot;); alert(D); 试试看，我们的D打出什么结果呢？结果是”abc”，所以说，模块工厂的实参只跟依赖项的定义有关，跟形参的顺序无关。我们看到，在AngularJS里面，并非如此，实参的顺序是跟形参一致的，这是怎么做到的呢？ 我们先离开代码，思考这么一个问题：如何得知函数的形参名数组？对，我们是可以用func.length得到形参个数，但无法得到每个形参的变量名，那怎么办呢？ AngularJS使用了一种比较极端的办法，分析了函数的字面量。众所周知，在JavaScript中，任何对象都隐含了toString方法，对于一个函数来说，它的toString就是自己的实现代码，包含函数签名和注释。下面我贴一下AngularJS里面的这部分代码： var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m; var FN_ARG_SPLIT = /,/; var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/; var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg; function annotate(fn) { var $inject, fnText, argDecl, last; if (typeof fn == &apos;function&apos;) { if (!($inject = fn.$inject)) { $inject = []; fnText = fn.toString().replace(STRIP_COMMENTS, &apos;&apos;); argDecl = fnText.match(FN_ARGS); forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){ arg.replace(FN_ARG, function(all, underscore, name){ $inject.push(name); }); }); fn.$inject = $inject; } } else if (isArray(fn)) { last = fn.length - 1; assertArgFn(fn[last], &apos;fn&apos;); $inject = fn.slice(0, last); } else { assertArgFn(fn, &apos;fn&apos;, true); } return $inject; } 可以看到，这个代码也不长，重点是类型为function的那段，首先去除了注释，然后获取了形参列表字符串，这段正则能获取到两个结果，第一个是全函数的实现，第二个才是真正的形参列表，取第二个出来split，就得到了形参的字符串列表了，然后按照这个顺序再去加载依赖模块，就可以让形参列表不对应于依赖项数组了。 AngularJS的这段代码很强大，但是要损耗一些性能，考虑到我们的框架首要原则是简单，甚至可以为此牺牲一些灵活性，我们不做这么复杂的事情了。 1.3 模块的加载到目前为止，我们可以把多个模块都定义在一个文件中，然后手动引入这个js文件，但是如果一个页面要引用很多个模块，引入工作就变得比较麻烦，比如说，单页应用程序（SPA）一般比较复杂，往往包含数以万计行数的js代码，这些代码至少分布在几十个甚至成百上千的模块中，如果我们也在主界面就加载它们，载入时间会非常难以接受。但我们可以这样看：主界面加载的时候，并不是用到了所有这些功能，能否先加载那些必须的，而把剩下的放在需要用的时候再去加载？ 所以我们可以考虑万能的AJAX，从服务端获取一个js的内容，然后……，怎么办，你当然说不能eval了，因为据说eval很evil啦，但是它evil在哪里呢？主要是破坏全局作用域啦，怎么怎么，但是如果这些文件里面都是按照我们规定的模块格式写，好像也没有什么在全局作用域的……，好吧。 算了，我们还是用最简单的方式了，就是动态创建script标签，然后设置src，添加到document.head里，然后监听它们的完成事件，做后续操作。真的很简单，因为我们的框架不需要考虑那么多种情况，不需要AMD，不需要require那么麻烦，用这框架的人必须按照这里的原则写。 所以，说真的我们这里没那么复杂啦，要是你们想看更详细原理的不如去看这个，解释得比我好哎：http://coolshell.cn/articles/9749.html#jtss-tsina 我也偷懒了，只是贴一下代码，顺便解释一下，界面把所依赖的js文件路径放在数组里，然后挨个创建script标签，src设置为路径，添加到head中，监听它们的完成事件。在这个完成时间里，我们要做这么一些事情：在fileMap里记录当前js文件的路径，防止以后重复加载，检查列表中所有文件，看看是否全部加载完了，如果全加载好了，就执行回调。 require: function (pathArr, callback) { for (var i = 0; i &lt; pathArr.length; i++) { var path = pathArr[i]; if (!fileMap[path]) { var head = document.getElementsByTagName(&apos;head&apos;)[0]; var node = document.createElement(&apos;script&apos;); node.type = &apos;text/javascript&apos;; node.async = &apos;true&apos;; node.src = path + &apos;.js&apos;; node.onload = function () { fileMap[path] = true; head.removeChild(node); checkAllFiles(); }; head.appendChild(node); } } function checkAllFiles() { var allLoaded = true; for (var i = 0; i &lt; pathArr.length; i++) { if (!fileMap[pathArr[i]]) { allLoaded = false; break; } } if (allLoaded) { callback(); } } } 1.4 小结到此为止，我们的简易框架的模块定义系统就完成了。完整的代码如下： (function () { var moduleMap = {}; var fileMap = {}; var noop = function () { }; var thin = { define: function(name, dependencies, factory) { if (!moduleMap[name]) { var module = { name: name, dependencies: dependencies, factory: factory }; moduleMap[name] = module; } return moduleMap[name]; }, use: function(name) { var module = moduleMap[name]; if (!module.entity) { var args = []; for (var i=0; i&lt;module.dependencies.length; i++) { if (moduleMap[module.dependencies[i]].entity) { args.push(moduleMap[module.dependencies[i]].entity); } else { args.push(this.use(module.dependencies[i])); } } module.entity = module.factory.apply(noop, args); } return module.entity; }, require: function (pathArr, callback) { for (var i = 0; i &lt; pathArr.length; i++) { var path = pathArr[i]; if (!fileMap[path]) { var head = document.getElementsByTagName(&apos;head&apos;)[0]; var node = document.createElement(&apos;script&apos;); node.type = &apos;text/javascript&apos;; node.async = &apos;true&apos;; node.src = path + &apos;.js&apos;; node.onload = function () { fileMap[path] = true; head.removeChild(node); checkAllFiles(); }; head.appendChild(node); } } function checkAllFiles() { var allLoaded = true; for (var i = 0; i &lt; pathArr.length; i++) { if (!fileMap[pathArr[i]]) { allLoaded = false; break; } } if (allLoaded) { callback(); } } } }; window.thin = thin; })(); 测试代码如下： thin.define(&quot;constant.PI&quot;, [], function() { return 3.14159; }); thin.define(&quot;shape.Circle&quot;, [&quot;constant.PI&quot;], function(pi) { var Circle = function(r) { this.r = r; }; Circle.prototype = { area : function() { return pi * this.r * this.r; } } return Circle; }); thin.define(&quot;shape.Rectangle&quot;, [], function() { var Rectangle = function(l, w) { this.l = l; this.w = w; }; Rectangle.prototype = { area: function() { return this.l * this.w; } }; return Rectangle; }); thin.define(&quot;ShapeTypes&quot;, [&quot;shape.Circle&quot;, &quot;shape.Rectangle&quot;], function(Circle, Rectangle) { return { CIRCLE: Circle, RECTANGLE: Rectangle }; }); thin.define(&quot;ShapeFactory&quot;, [&quot;ShapeTypes&quot;], function(ShapeTypes) { return { getShape: function(type) { var shape; switch (type) { case &quot;CIRCLE&quot;: { shape = new ShapeTypes[type](arguments[1]); break; } case &quot;RECTANGLE&quot;: { shape = new ShapeTypes[type](arguments[1], arguments[2]); break; } } return shape; } }; }); var ShapeFactory = thin.use(&quot;ShapeFactory&quot;); alert(ShapeFactory.getShape(&quot;CIRCLE&quot;, 5).area()); alert(ShapeFactory.getShape(&quot;RECTANGLE&quot;, 3, 4).area()); 在这个例子里定义了四个模块，每个模块只需要定义自己所直接依赖的模块，其他的可以不必定义。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于AngularJS构建Web应用门户]]></title>
    <url>%2F2016%2F03%2F05%2F%E5%9F%BA%E4%BA%8EAngularJS%E6%9E%84%E5%BB%BAWeb%E5%BA%94%E7%94%A8%E9%97%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[我们常常遇到有构建Web应用门户的需求， 大型单页应用要做的第一件事就是分层架构。分层架构有利于把职责清晰化，每块可以单独做测试。 数据模型层必须独立出来，所以有些Angular文章推荐给所有service建一个module，然后把一切包含数据模型的service都放进去。可以这么做，也可以再细分。 分层做完，就要考虑懒加载的问题了。 我们看看一个典型的场景，一个工作台，或者说门户界面，上面能够放很多小部件，类似iGoogle那样，用户可以任意加已有的部件，这些部件都是基于某种约定，由第三方开发人员完成。这种如果在单页应用里，该怎么实现呢？ 企业应用门户的设计，其实是一个很考验规划水准的事。因为它首先要集成别人，还要考虑如何被别人集成。它的设计思路直接影响到一大堆代码按照什么规范进行开发。挂在这个门户上的业务模块，有的很简单，不会影响别人，有的可能会影响别人，要想个办法把它隔离起来，还有的本身就要跟别人通讯。 先来看部件有些什么可以做的事。他可以有界面，有逻辑，有样式。这些都可以分别动态加载出来，比如HTML片段可以ng-include或者$get过来append，js文件可以require，css可以行间也可以动态加rule，因为这些部件是要跟我们主界面在同一个页面作用域内，所以要尽量营造隔离的环境。 1. 无逻辑的界面部件如果是纯HTML话很好办，它直接拿来放在某容器里就可以了，互相影响不到，直接搞个ng-include把它包含到主界面就可以了。 &lt;div ng-include src=&quot;&apos;partial/simple.html&apos;&quot;&gt;&lt;/div&gt; 我们来写个directive专门做部件加载器吧。先来个最简单的： portal.directive(&quot;htmlLoader&quot;, function ($http) { return function (scope, element, attrs) { var url = attrs.url; $http.get(url).success(function (result) { element.html(result); }); }; }); 用的时候也很简单： &lt;div html-loader url=&quot;partial/simple.html&quot;&gt;&lt;/div&gt; 可以看到，纯HTML模版加载非常简单，只要取过来放置到元素上就好了。 2. 带行间逻辑的界面部件什么是行间逻辑呢？意思是这一段JavaScript逻辑只作用于当前界面片段，出于某些原因，这些逻辑必须紧跟当前的界面，需要在全页面加载出来之前就能执行，比如某些搜索，只要搜索框一出来就应当能操作，这就是一种典型的需求。 我们看看刚才的这种加载器，里面用了element.html(result)，这么做显然不能执行这个result中含有的JavaScript代码，怎么办呢？ 我们想个办法来把js分离出来： 3. 有独立命名空间的界面部件JavaScript的话，最基本的就是避免全局变量，在Angular体系中，还需要作些特殊的考虑。我们知道，Angular里面，第一级组织单元是module，但它这个module的概念跟AMD那种module的不同，如果说AMD的module相当于Java Class的级别，Angular的要相当于package了。 这就有了我们的第一个问题：部件里面的JavaScript代码跟主界面的在不在一个module内？如果是别的框架，这不是个问题，但这货是Angular，有些纠结，这里面还分两种情况： 部件很独立，相互无任何协作关系 部件之间有协作，包括可能共享代码或者有通信 第一种很好办，我们可以让这个部件自己定义ng-app，这样它就是一个独立隔离的环境了。来写一下代码： portal.module(&quot;mis&quot;).directive(&quot;appLoader&quot;, function ($http) { return function (scope, element, attrs) { var module = attrs.module; var url = attrs.url; var scripts = attrs.scripts.split(&quot;,&quot;) || []; $script(scripts, function () { scope.$apply(function () { $http.get(url).success(function (result) { var elem = angular.element(result); angular.bootstrap(elem, [module]); element.append(elem); }); }); }); }; }); 部件代码： clock.html &lt;div ng-controller=&quot;ClockCtrl&quot;&gt; &lt;span ng-bind=&quot;now&quot;&gt;&lt;/span&gt; &lt;/div&gt; clock.js angular.module(&quot;widgets&quot;, []); angular.module(&quot;widgets&quot;).controller(&quot;ClockCtrl&quot;, function($timeout, $scope) { $scope.now = new Date(); updateLater(); var timeoutId; function updateLater() { $scope.now = new Date(); timeoutId = $timeout(function() { updateLater(); }, 1000); } }); 使用的时候： &lt;div app-loader url=&quot;partial/clock.html&quot; module=&quot;widgets&quot; scripts=&quot;js/widgets/clock.js&quot;&gt;&lt;/div&gt; 分析这段代码，可以看到，这里要做两件事：加载依赖项的js文件，加载html片段，然后简单粗暴地调用了Angular的bootstrap方法，这是什么意思呢？ Angular可以用两种方式来初始化，第一种是通过在标签上写ng-app，然后页面加载的时候会自动做这个事情，第二种是直接调用angular.bootstrap方法，手动初始化。 我们新加载的这个部件因为拥有独立命名空间，所以它的js代码里面也会很独立，在clock.js里面新定义了一个module叫做widgets，整个部件都运行在这个命名空间下。 到这里，事情也没结束，因为我们这里只演示了一个 4. 跟主界面共享命名空间的部件第二种很麻烦，因为Angular的module依赖关系想要动态加很复杂，所以我们只能约定已有的module，然后让部件的js从这个module上加自己的代码。 portal.directive(&quot;partialLoader&quot;, function ($http, $compile) { return function (scope, element, attrs) { var module = attrs.module; var url = attrs.url; var scripts = attrs.scripts.split(&quot;,&quot;) || []; $script(scripts, function () { scope.$apply(function () { $http.get(url).success(function (result) { element.html(result); $compile(element.contents())(scope); }); }); }); }; }); 使用的时候： &lt;div partial-loader url=&quot;partial/goods.html&quot; scripts=&quot;js/order/goods.js&quot;&gt;&lt;/div&gt; 有时候会有 5. 已载入文件的缓存6. 样式的隔离CSS的隔离也比麻烦，因为样式是全局生效的，我们必须约定某种规则，让第三方开发者的样式只能挂在他这个部件下，无论是行间样式还是引入的外部样式，都不能起到这个限制的作用。所以，必须使用更苛刻的手段。 思路肯定是要从某种元素往下写的，我们给他一个特定元素，他以这个为基准，所有自己的CSS都定义在这个元素的选择符之下。那么，这些不同的部件之间，又要如何区分呢？ 想想，部件之间其实只有很少东西能用于区分，比如说全局唯一的部件名，所以，我们以此为依据，这样来约定： 在主界面中包含部件的容器，生成一个如下的元素： 这样 &lt;div data-appname=&quot;sampleApp&quot;&gt;&lt;/div&gt; 真实的部件HTML代码会被放置在其中，举例来说，这个部件的HTML是： &lt;ul&gt; &lt;li&gt;Apple&lt;/li&gt; &lt;li&gt;Pear&lt;/li&gt; &lt;/ul&gt; 它的CSS就可以这么写： div[data-appname=&quot;sampleApp&quot;] ul { }]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程——基础篇]]></title>
    <url>%2F2015%2F06%2F28%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前端工程——基础篇 喂喂喂，那个切图的，把页面写好就发给研发工程师套模板吧。 你好，切图仔。 不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。 只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。 前端，是一种GUI软件现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台…… 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件： 尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。 历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！ 前端工程的三个阶段现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段： 第一阶段：库/框架选型 前端工程建设的第一项任务就是根据项目特征进行技术选型。 基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。 第二阶段：简单构建优化 选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。 第三阶段：JS/CSS模块化开发 分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。 很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。 JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。 然而，做到这些就够了么？Naive！ 第四阶段 前端是一种技术问题较少、工程问题较多的软件开发领域。 当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如： 大体量：多功能、多页面、多状态、多系统； 大规模：多人甚至多团队合作开发； 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。 扩展阅读：大公司里怎样开发和部署前端代码？ 这些无疑是一系列严肃的系统工程问题。 前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。 到底，缺什么呢？ 没有银弹读过《人月神话》的人应该都听说过，软件工程 没有银弹。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔） 前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。 重你妹！你的脑容量只有4K吗？ 工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！ 2011年我有幸参与到 FIS 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。 这些经历让我明悟了一个道理： 进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。 第一件事：组件化开发分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求： 如上图，这是我所信仰的前端组件化开发理念，简单解读一下： 页面上的每个 独立的 可视/可交互区域视为一个组件； 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护； 由于组件具有独立性，因此组件与组件之间可以 自由组合； 页面只不过是组件的容器，负责组合组件形成功能完整的界面； 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。 其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。 组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板： 不同的技术选型决定了不同的组件封装和调用策略。 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分： 由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。 结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念： 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子： 示意图 描述 整个Web应用由页面组成 页面由组件组成 一个组件一个目录，资源就近维护 组件可组合，组件的JS可依赖其他JS模块，CSS可依赖其他CSS单元 综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构： 如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。 以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。 吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。 第二件事：“智能”静态资源管理上面提到的模块化/组件化开发，仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了。 很明显，模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。然而前端与客户端GUI软件有一个很大的不同： 前端是一种远程部署，运行时增量下载的GUI软件 前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。 上图展示了一款界面繁多功能丰富的应用，如果采用Web实现，相信也是不小的体量，如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。 这正是Web应用“免安装”的魅力所在。 由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。 所以我觉得： 第四阶段前端开发最迫切需要做好的就是在基础架构中贯彻增量原则。 相信这种贯彻不会随着时间的推移而改变，在可预见的未来，无论在HTTP1.x还是HTTP2.0时代，无论在ES5亦或者ES6/7时代，无论是AMD/CommonJS/UMD亦或者ES6 module时代，无论端内技术如何变迁，我们都有足够充分的理由要做好前端程序资源的增量加载。 正如前面说到的，第三阶段前端工程缺少点什么呢？我觉得是在其基础架构中缺少这样一种“智能”的资源加载方案。没有这样的方案，很难将前端应用的规模发展到第四阶段，很难实现落地前面介绍的那种组件化开发方案，也很难让多方合作高效率的完成一项大型应用的开发，并保证其最终运行性能良好。在第四阶段，我们需要强大的工程化手段来管理”玩具般简单“的前端开发。 在我的印象中，Facebook是这方面探索的伟大先驱之一，早在2010年的Velocity China大会上，来自Facebook的David Wei博士就为业界展示了他们令人惊艳的静态网页资源管理和优化技术。 David Wei博士在当年的交流会上提到过一些关于Facebook的一些产品数据： Facebook整站有10000+个静态资源； 每个静态资源都有可能被翻译成超过100种语言版本； 每种资源又会针对浏览器生成3种不同的版本； 要针对不同带宽的用户做5种不同的打包方法； 有3、4个不同的用户组，用于小批次体验新的产品功能； 还要考虑不同的送达方法，可以直接送达，或者通过iframe的方式提升资源并行加载的速度； 静态资源的压缩和非压缩状态可切换，用于调试和定位线上问题 这是一个状态爆炸的问题，将所有状态乘起来，整个网站的资源组合方式会达到几百万种之多（去重之后统计大概有300万种组合方式）。支撑这么大规模前端项目运行的底层架构正是魏博士在那次演讲中分享的Static Resource Management System(静态资源管理系统)，用以解决Facebook项目中有关前端工程的3D问题（Development，Deployment，Debugging）。 那段时间 FIS 项目正好遇到瓶颈，当时的FIS还是一个用php写的task-based构建工具，那时候对于前端工程的认知度很低，觉得前端构建不就是几个压缩优化校验打包任务的组合吗，写好流程调度，就针对不同需求写插件呗，看似非常简单。但当我们支撑越来越多的业务团队，接触到各种不同的业务场景时，我们深刻的感受到task-based工具的粗糙，团队每天疲于根据各种业务场景编写各种打包插件，构建逻辑异常复杂，隐隐看到不可控的迹象。 我们很快意识到把基础架构放到构建工具中实现是一件很愚蠢的事，试图依靠构建工具实现各种优化策略使得构建变成了一个巨大的黑盒，一旦发生问题，定位起来非常困难，而且每种业务场景都有不同的优化需求，构建工具只能通过静态分析来优化加载，具有很大的局限性，单页面/多页面/PC端/移动端/前端渲染/后端渲染/多语言/多皮肤/高级优化等等资源加载问题，总不能给每个都写一套工具吧，更何况这些问题彼此之间还可以有多种组合应用，工具根本写不过来。 Facebook的做法无疑为我们亮起了一盏明灯，不过可惜它并不开源（不是技术封锁，而是这个系统依赖FB体系中的其他方面，通用性不强，开源意义不大），我们只能尝试挖掘相关信息，网上对它的完整介绍还是非常非常少，分析facebook的前端代码也没有太多收获，后来无意中发现了facebook使用的项目管理工具phabricator中的一个静态管理方案Celerity，以及相关的说明，看它的描述很像是Facebook静态资源管理系统的一个mini版！ 简单看过整个系统之后发现原理并不复杂（小而美的典范），它是通过一个小工具扫描所有静态资源，生成一张资源表，然后有一个PHP实现的资源管理框架（Celerity）提供了资源加载接口，替代了传统的script/link等静态的资源加载标签，最终通过查表来加载资源。 虽然没有真正看过FB的那套系统，但眼前的这个小小的框架给了当时的我们足够多的启示： 静态资源管理系统 = 资源表 + 资源加载框架 多么优雅的实现啊！ 资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容，比如： 12345678910111213141516&#123; "a.js": &#123; "url": "/static/js/a.5f100fa.js", "dep": [ "b.js", "a.css" ] &#125;, "a.css": &#123; "url": "/static/css/a.63cf374.css", "dep": [ "button.css" ] &#125;, "b.js": &#123; "url": "/static/js/b.97193bf.js" &#125;, "button.css": &#123; "url": "/static/css/button.de33108.css" &#125;&#125; 而资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。 根据业务场景的不同，加载框架可以在浏览器中用JS实现，也可以是后端模板引擎中用服务端语言实现，甚至二者的组合，不一而足。 有关加载框架的具体实现我曾写过很多文章介绍，可以扩展阅读： 前端工程与性能优化 前端工程与模块化框架 这种设计很快被验证具有足够的灵活性，能够完美支撑不同团队不同技术规范下的性能优化需求，前面提到的按需加载、延迟加载、预加载、请求合并、文件指纹、CDN部署、Bigpipe、Quickling、BigRender、首屏CSS内嵌、HTTP 2.0服务端推送等等性能优化手段都可以很容易的在这种架构上实现，甚至可以根据性能日志自动进行优化（Facebook已实现）。 因为有了资源表，我们可以很方便的控制资源加载，通过各种手段在运行时计算页面的资源使用情况，从而获得最佳加载性能。无论是前端渲染的单页面应用，还是后端渲染的多页面应用，这种方法都同样适用。 此外，它还很巧妙的约束了构建工具的职责——只生成资源表。资源表是非常通用的数据结构，无论什么业务场景，其业务代码最终都可以被扫描为相同结构的表数据，并标记资源间的依赖关系，有了表之后我们只需根据不同的业务场景定制不同的资源加载框架就行了，从此彻底告别一个团队维护一套工具的时代！！！ 恩，如你所见，虽然彻底告别了一个团队一套工具的时代，但似乎又进入了一个团队一套框架的时代。其实还是有差别的，因为框架具有很大的灵活性，而且不那么黑盒，采用框架实现资源管理相比构建更容易调试、定位和升级变更。 深耕静态资源加载框架可以带来许多收益，而且有足够的灵活性和健壮性面向未来的技术变革，这个我们留作后话。 总结回顾一下前面提到过的前端工程三个阶段： 第一阶段：库/框架选型 第二阶段：简单构建优化 第三阶段：JS/CSS模块化开发 现在补充上第四阶段： 第四阶段：组件化开发与资源管理 由于先天缺陷，前端相比其他软件开发，在基础架构上更加迫切的需要组件化开发和资源管理，而解决资源管理的方法其实一点也不复杂： 一个通用的资源表生成工具 + 基于表的资源加载框架 近几年来各种你听到过的各种资源加载优化策略大部分都可以在这样一套基础上实现，而这种优化对于业务来说是完全透明的，不需要重构的性能优化——这不正是我们一直所期盼的吗？正如魏小亮博士所说：我们可以把优秀的人集中起来去优化加载。 如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说： 你好，工程师！ 前端工程其实是一个很大的话题，开发仅是其中的一部分。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程与性能优化]]></title>
    <url>%2F2015%2F05%2F24%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端工程与性能优化每个参与过开发企业级web应用的前端工程师或许都曾思考过前端性能优化方面的问题。我们有雅虎14条性能优化原则，还有两本很经典的性能优化指导书：《高性能网站建设指南》、《高性能网站建设进阶指南》。经验丰富的工程师对于前端性能优化方法耳濡目染，基本都能一一列举出来。这些性能优化原则大概是在7年前提出的，对于web性能优化至今都有非常重要的指导意义。 然而，对于构建大型web应用的团队来说，要坚持贯彻这些优化原则并不是一件十分容易的事。因为优化原则中很多要求是与工程管理相违背的，比如 把css放在头部 和 把js放在尾部 这两条原则，我们不能让团队的工程师在写样式和脚本引用的时候都去修改一个相同的页面文件。这样做会严重影响团队成员间并行开发的效率，尤其是在团队有版本管理的情况下，每天要花大量的时间进行代码修改合并，这项成本是难以接受的。因此在前端工程界，总会看到周期性的性能优化工作，辛勤的前端工程师们每到月圆之夜就会倾巢出动根据优化原则做一次性能优化。 性能优化是一个工程问题 本文将从一个全新的视角来思考web性能优化与前端工程之间的关系，揭示前端性能优化在前端架构及开发工具设计层面的实现思路。 性能优化原则及分类po主先假设本文的读者是有前端开发经验的工程师，并对企业级web应用开发及性能优化有一定的思考，因此我不会重复介绍雅虎14条性能优化原则。如果您没有这些前续知识，请移步 这里 来学习。 首先，我们把雅虎14条优化原则，《高性能网站建设指南》以及《高性能网站建设进阶指南》中提到的优化点做一次梳理，按照优化方向分类，可以得到这样一张表格： 优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 开启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 目前大多数前端团队可以利用 yui compressor 或者 google closure compiler 等压缩工具很容易做到 精简Javascript 这条原则；同样的，也可以使用图片压缩工具对图像进行压缩，实现 图像优化 原则。这两条原则是对单个资源的处理，因此不会引起任何工程方面的问题。很多团队也通过引入代码校验流程来确保实现 避免css表达式 和 避免重定向 原则。目前绝大多数互联网公司也已经开启了服务端的Gzip压缩，并使用CDN实现静态资源的缓存和快速访问；一些技术实力雄厚的前端团队甚至研发出了自动CSS Sprites工具，解决了CSS Sprites在工程维护方面的难题。使用“查找-替换”思路，我们似乎也可以很好的实现 划分主域 原则。 我们把以上这些已经成熟应用到实际生产中的优化手段去除掉，留下那些还没有很好实现的优化原则。再来回顾一下之前的性能优化分类： 优化方向 优化手段 请求数量 合并脚本和样式表，拆分初始化负载 请求带宽 移除重复脚本 缓存利用 添加Expires头，配置ETag，使Ajax可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 有很多顶尖的前端团队可以将上述还剩下的优化原则也都一一解决，但业界大多数团队都还没能很好的解决这些问题。因此，本文将就这些原则的解决方案做进一步的分析与讲解，从而为那些还没有进入前端工业化开发的团队提供一些基础技术建设意见，也借此机会与业界顶尖的前端团队在工业化工程化方向上交流一下彼此的心得。 静态资源版本更新与缓存缓存利用 分类中保留了 添加Expires头 和 配置ETag 两项。或许有些人会质疑，明明这两项只要配置了服务器的相关选项就可以实现，为什么说它们难以解决呢？确实，开启这两项很容易，但开启了缓存后，我们的项目就开始面临另一个挑战： 如何更新这些缓存？ 相信大多数团队也找到了类似的答案，它和《高性能网站建设指南》关于“添加Expires头”所说的原则一样——修订文件名。即： 最有效的解决方案是修改其所有链接，这样，全新的请求将从原始服务器下载最新的内容。 思路没错，但要怎么改变链接呢？变成什么样的链接才能有效更新缓存，又能最大限度避免那些没有修改过的文件缓存不失效呢？ 先来看看现在一般前端团队的做法： 1234567&lt;h1&gt;hello world&lt;/h1&gt;&lt;script type="text/javascript" src="a.js?t=201503241123"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js?t=201503241123"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js?t=201503241123"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js?t=201503241123"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="e.js?t=201503241123"&gt;&lt;/script&gt; ps: 也有团队采用构建版本号为静态资源请求添加query，它们在本质上是没有区别的，在此就不赘述了。 接下来，项目升级，比如页面上的html结构发生变化，对应还要修改 a.js 这个文件，得到的构建结果如下： 1234567&lt;header&gt;hello world&lt;/header&gt;&lt;script type="text/javascript" src="a.js?t=201503241826"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js?t=201503241826"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js?t=201503241826"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js?t=201503241826"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="e.js?t=201503241826"&gt;&lt;/script&gt; 为了触发用户浏览器的缓存更新，我们需要更改静态资源的url地址，如果采用构建信息（时间戳、版本号等）作为url修改的依据，如上述代码所示，我们只修改了一个a.js文件，但再次构建会让所有请求都更改了url地址，用户再度访问页面那些没有修改过的静态资源的(b.js，b.js，c.js，d.js，e.js)的浏览器缓存也一同失效了。 使用构建信息作为静态资源更新标记会导致每次构建发布后所有静态资源都被迫更新，浏览器缓存利用率降低，给性能带来伤害。 此外，采用添加query的方式来清除缓存还有一个弊端，就是 覆盖式发布 的上线问题。 采用query更新缓存的方式实际上要覆盖线上文件的，index.html和a.js总有一个先后的顺序，从而中间出现一段或大或小的时间间隔。尤其是当页面是后端渲染的模板的时候，静态资源和模板是部署在不同的机器集群上的，上线的过程中，静态资源和页面文件的部署时间间隔可能会非常长，对于一个大型互联网应用来说即使在一个很小的时间间隔内，都有可能出现新用户访问。在这个时间间隔中，访问了网站的用户会发生什么情况呢？ 如果先覆盖index.html，后覆盖a.js，用户在这个时间间隙访问，会得到新的index.html配合旧的a.js的情况，从而出现错误的页面。 如果先覆盖a.js，后覆盖index.html，用户在这个间隙访问，会得到旧的index.html配合新的a.js的情况，从而也出现了错误的页面。 这就是为什么大型web应用在版本上线的过程中经常会较集中的出现前端报错日志的原因，也是一些互联网公司选择加班到半夜等待访问低峰期再上线的原因之一。 对于静态资源缓存更新的问题，目前来说最优方案就是 基于文件内容的hash版本冗余机制 了。也就是说，我们希望项目源码是这么写的： 1&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt; 发布后代码变成 1&lt;script type="text/javascript" src="a_8244e91.js"&gt;&lt;/script&gt; 也就是a.js发布出来后被修改了文件名，产生一个新文件，并不是覆盖已有文件。其中”_82244e91”这串字符是根据a.js的文件内容进行hash运算得到的，只有文件内容发生变化了才会有更改。由于将文件发布为带有hash的新文件，而不是同名文件覆盖，因此不会出现上述说的那些问题。同时，这么做还有其他的好处： 上线的a.js不是同名文件覆盖，而是文件名+hash的冗余，所以可以先上线静态资源，再上线html页面，不存在间隙问题； 遇到问题回滚版本的时候，无需回滚a.js，只须回滚页面即可； 由于静态资源版本号是文件内容的hash，因此所有静态资源可以开启永久强缓存，只有更新了内容的文件才会缓存失效，缓存利用率大增； 以文件内容的hash值为依据生产新文件的非覆盖式发布策略是解决静态资源缓存更新最有效的手段。 虽然这种方案是相比之下最完美的解决方案，但它无法通过手工的形式来维护，因为要依靠手工的形式来计算和替换hash值，并生成相应的文件，将是一项非常繁琐且容易出错的工作，因此我们需要借助工具来处理。 用grunt来实现md5功能是非常困难的，因为grunt只是一个task管理器，而md5计算需要构建工具具有递归编译的能，而不是简单的任务调度。考虑这样的例子： 由于我们的资源版本号是通过对文件内容进行hash运算得到，如上图所示，index.html中引用的a.css文件的内容其实也包含了a.png的hash运算结果，因此我们在修改index.html中a.css的引用时，不能直接计算a.css的内容hash，而是要先计算出a.png的内容hash，替换a.css中的引用，得到了a.css的最终内容，再做hash运算，最后替换index.html中的引用。 计算index.html中引用的a.css文件的url过程： 压缩a.png后计算其内容的md5值 将a.png的md5写入a.css，再压缩a.css，计算其内容的md5值 将a.css的md5值写入到index.html中 grunt等task-based的工具是很难在task之间协作处理这样的需求的。 在解决了基于内容hash的版本更新问题之后，我们可以将所有前端静态资源开启永久强缓存，每次版本发布都可以首先让静态资源全量上线，再进一步上线模板或者页面文件，再也不用担心各种缓存和时间间隙的问题了！ 静态资源管理与模块化框架解决了静态资源缓存问题之后，让我们再来看看前面的优化原则表还剩些什么： 优化方向 优化手段 请求数量 合并脚本和样式表，拆分初始化负载 请求带宽 移除重复脚本 缓存利用 使Ajax可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 很不幸，剩下的优化原则都不是使用工具就能很好实现的。或许有人会辩驳：“我用某某工具可以实现脚本和样式表合并”。嗯，必须承认，使用工具进行资源合并并替换引用或许是一个不错的办法，但在大型web应用，这种方式有一些非常严重的缺陷，来看一个很熟悉的例子 ： 某个web产品页面有A、B、C三个资源 工程师根据“减少HTTP请求”的优化原则合并了资源 产品经理要求C模块按需出现，此时C资源已出现多余的可能 C模块不再需要了，注释掉吧！代码1秒钟搞定，但C资源通常不敢轻易剔除 不知不觉中，性能优化变成了性能恶化…… 这个例子来自 Facebook静态网页资源的管理和优化@Velocity China 2010 事实上，使用工具在线下进行静态资源合并是无法解决资源按需加载的问题的。如果解决不了按需加载，则必会导致资源的冗余；此外，线下通过工具实现的资源合并通常会使得资源加载和使用的分离，比如在页面头部或配置文件中写资源引用及合并信息，而用到这些资源的html组件写在了页面其他地方，这种书写方式在工程上非常容易引起维护不同步的问题，导致使用资源的代码删除了，引用资源的代码却还在的情况。因此，在工业上要实现资源合并至少要满足如下需求： 确实能减少HTTP请求，这是基本要求（合并） 在使用资源的地方引用资源（就近依赖），不使用不加载（按需） 虽然资源引用不是集中书写的，但资源引用的代码最终还能出现在页面头部（css）或尾部（js） 能够避免重复加载资源（去重） 将以上要求综合考虑，不难发现，单纯依靠前端技术或者工具处理是很难达到这些理想要求的。 接下来我会讲述一种新的模板架构设计，用以实现前面说到那些性能优化原则，同时满足工程开发和维护的需要，这种架构设计的核心思想就是： 基于依赖关系表的静态资源管理系统与模块化框架设计 考虑一段这样的页面代码： 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="a.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="b.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="c.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;div&gt; content of module c &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 根据资源合并需求中的第二项，我们希望资源引用与使用能尽量靠近，这样将来维护起来会更容易一些，因此，理想的源码是： 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;link rel="stylesheet" type="text/css" href="a.css"/&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;link rel="stylesheet" type="text/css" href="b.css"/&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;link rel="stylesheet" type="text/css" href="c.css"/&gt; &lt;div&gt; content of module c &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当然，把这样的页面直接送达给浏览器用户是会有严重的页面闪烁问题的，所以我们实际上仍然希望最终页面输出的结果还是如最开始的截图一样，将css放在头部输出。这就意味着，页面结构需要有一些调整，并且有能力收集资源加载需求，那么我们考虑一下这样的源码（以php为例）： 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;!--[ CSS LINKS PLACEHOLDER ]--&gt;&lt;/head&gt;&lt;body&gt; &lt;?php require_static('a.css'); ?&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;?php require_static('b.css'); ?&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;?php require_static('c.css'); ?&gt; &lt;div&gt; content of module c &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在页面的头部插入一个html注释 &lt;!--[CSS LINKS PLACEHOLDER]--&gt; 作为占位，而将原来字面书写的资源引用改成模板接口 require_static 调用，该接口负责收集页面所需资源。 require_static接口实现非常简单，就是准备一个数组，收集资源引用，并且可以去重。最后在页面输出的前一刻，我们将require_static在运行时收集到的 a.css、b.css、c.css 三个资源拼接成html标签，替换掉注释占位 &lt;!--[CSS LINKS PLACEHOLDER]--&gt;，从而得到我们需要的页面结构。 经过实践总结，可以发现模板层面只要实现三个开发接口，就可以比较完美的实现目前遗留的大部分性能优化原则，这三个接口分别是： require_static(res_id)：收集资源加载需求的接口，参数是静态资源id。 load_widget(wiget_id)：加载拆分成小组件模板的接口。你可以叫它为widget、component或者pagelet之类的。总之，我们需要一个接口把一个大的页面模板拆分成一个个的小部分来维护，最后在原来的页面中以组件为单位来加载这些小部件。 script(code)：收集写在模板中的js脚本，使之出现的页面底部，从而实现性能优化原则中的 将js放在页面底部 原则。 实现了这些接口之后，一个重构后的模板页面的源代码可能看起来就是这样的了： 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;?php require_static('jquery.js'); ?&gt; &lt;?php require_static('bootstrap.css'); ?&gt; &lt;?php require_static('bootstrap.js'); ?&gt; &lt;!--[ CSS LINKS PLACEHOLDER ]--&gt;&lt;/head&gt;&lt;body&gt; &lt;?php load_widget('a'); ?&gt; &lt;?php load_widget('b'); ?&gt; &lt;?php load_widget('c'); ?&gt; &lt;!--[ SCRIPTS PLACEHOLDER ]--&gt;&lt;/body&gt;&lt;/html&gt; 而最终在模板解析的过程中，资源收集与去重、页面script收集、占位符替换操作，最终从服务端发送出来的html代码为： 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="bootstrap.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="a.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="b.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="c.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;div&gt; content of module c &lt;/div&gt; &lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="bootstrap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="b.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="c.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 不难看出，我们目前已经实现了 按需加载，将脚本放在底部，将样式表放在头部 三项优化原则。 前面讲到静态资源在上线后需要添加hash戳作为版本标识，那么这种使用模板语言来收集的静态资源该如何实现这项功能呢？ 答案是：静态资源依赖关系表。 考虑这样的目录结构： project ├── widget │ ├── a │ │ ├── a.css │ │ ├── a.js │ │ └── a.php │ ├── b │ │ ├── b.css │ │ ├── b.js │ │ └── b.php │ └── c │ ├── c.css │ ├── c.js │ └── c.php ├── bootstrap.css ├── bootstrap.js ├── index.php └── jquery.js 如果我们可以使用工具扫描整个project目录，然后创建一张资源表，同时记录每个资源的部署路径，得到这样的一张表： 1234567891011121314&#123; "res" : &#123; "widget/a/a.css" : "/widget/a/a_1688c82.css", "widget/a/a.js" : "/widget/a/a_ac3123s.js", "widget/b/b.css" : "/widget/b/b_52923ed.css", "widget/b/b.js" : "/widget/b/b_a5cd123.js", "widget/c/c.css" : "/widget/c/c_03cab13.css", "widget/c/c.js" : "/widget/c/c_bf0ae3f.js", "jquery.js" : "/jquery_9151577.js", "bootstrap.css" : "/bootstrap_f5ba12d.css", "bootstrap.js" : "/bootstrap_a0b3ef9.js" &#125;, "pkg" : &#123;&#125;&#125; 基于这张表，我们就很容易实现 require_static(file_id)，load_widget(widget_id) 这两个模板接口了。以load_widget为例： 12345678910111213141516171819function load_widget($id)&#123; //从json文件中读取资源表 $map = load_map(); //查找静态资源 $filename = 'widget/' . $id . '/' . $id; //查找js文件 $js = $filename . '.js'; if(isset($map['res'][$js])) &#123; //如果有对应的js资源，就收集起来 collect_js_static($map['res'][$js]); &#125; //查找css文件 $css = $filename . '.css'; if(isset($map['res'][$css])) &#123; //如果有对应的css资源，就收集起来 collect_css_static($map['res'][$css]); &#125; include $filename . '.php';&#125; 利用查表来解决md5戳的问题，这样，我们的页面最终送达给用户的结果就是这样的： 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="/bootstrap_f5ba12d.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="/widget/a/a_1688c82.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="/widget/b/b_52923ed.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="/widget/c/c_03cab13.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;div&gt; content of module c &lt;/div&gt; &lt;script type="text/javascript" src="/jquery_9151577.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/bootstrap_a0b3ef9.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/widget/a/a_ac3123s.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/widget/b/b_a5cd123.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/widget/c/c_bf0ae3f.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接下来，我们讨论基于表的设计思想上是如何实现静态资源合并的。或许有些团队使用过combo服务，也就是我们在最终拼接生成页面资源引用的时候，并不是生成多个独立的link标签，而是将资源地址拼接成一个url路径，请求一种线上的动态资源合并服务，从而实现减少HTTP请求的需求，比如前面的例子，稍作调整即可得到这样的结果： 123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="/??bootstrap_f5ba12d.css,widget/a/a_1688c82.css,widget/b/b_52923ed.css,widget/c/c_03cab13.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;div&gt; content of module c &lt;/div&gt; &lt;script type="text/javascript" src="/??jquery_9151577.js,bootstrap_a0b3ef9.js,widget/a/a_ac3123s.js,widget/b/b_a5cd123.js,widget/c/c_bf0ae3f.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个 /??file1,file2,file3,… 的url请求响应就是动态combo服务提供的，它的原理很简单，就是根据url找到对应的多个文件，合并成一个文件来响应请求，并将其缓存，以加快访问速度。 这种方法很巧妙，有些服务器甚至直接集成了这类模块来方便的开启此项服务，这种做法也是大多数大型web应用的资源合并做法。但它也存在一些缺陷： 浏览器有url长度限制，因此不能无限制的合并资源。 如果用户在网站内有公共资源的两个页面间跳转访问，由于两个页面的combo的url不一样导致用户不能利用浏览器缓存来加快对公共资源的访问速度。 如果combo的url中任何一个文件发生改变，都会导致整个url缓存失效，从而导致浏览器缓存利用率降低。 对于上述第二条缺陷，可以举个例子来看说明： 假设网站有两个页面A和B A页面使用了a，b，c，d四个资源 B页面使用了a，b，e，f四个资源 如果使用combo服务，我们会得： A页面的资源引用为：/??a,b,c,d B页面的资源引用为：/??a,b,e,f 两个页面引用的资源是不同的url，因此浏览器会请求两个合并后的资源文件，跨页面访问没能很好的利用a、b这两个资源的缓存。 很明显，如果combo服务能聪明的知道A页面使用的资源引用为 /??a,b 和 /??c,d，而B页面使用的资源引用为 /??a,b 和 /??e,f就好了。这样当用户在访问A页面之后再访问B页面时，只需要下载B页面的第二个combo文件即可，第一个文件已经在访问A页面时缓存好了的。 基于这样的思考，我们在资源表上新增了一个字段，取名为 pkg，就是资源合并生成的新资源，表的结构会变成： 123456789101112131415161718192021222324252627282930313233343536373839&#123; "res" : &#123; "widget/a/a.css" : "/widget/a/a_1688c82.css", "widget/a/a.js" : "/widget/a/a_ac3123s.js", "widget/b/b.css" : "/widget/b/b_52923ed.css", "widget/b/b.js" : "/widget/b/b_a5cd123.js", "widget/c/c.css" : "/widget/c/c_03cab13.css", "widget/c/c.js" : "/widget/c/c_bf0ae3f.js", "jquery.js" : "/jquery_9151577.js", "bootstrap.css" : "/bootstrap_f5ba12d.css", "bootstrap.js" : "/bootstrap_a0b3ef9.js" &#125;, "pkg" : &#123; "p0" : &#123; "url" : "/pkg/lib_cef213d.js", "has" : [ "jquery.js", "bootstrap.js" ] &#125;, "p1" : &#123; "url" : "/pkg/lib_afec33f.css", "has" : [ "bootstrap.css" ] &#125;, "p2" : &#123; "url" : "/pkg/widgets_22feac1.js", "has" : [ "widget/a/a.js", "widget/b/b.js", "widget/c/c.js" ] &#125;, "p3" : &#123; "url" : "/pkg/widgets_af23ce5.css", "has" : [ "widget/a/a.css", "widget/b/b.css", "widget/c/c.css" ] &#125; &#125;&#125; 相比之前的表，可以看到新表中多了一个pkg字段，并且记录了打包后的文件所包含的独立资源。这样，我们重新设计一下 require_static、load_widget 这两个模板接口，实现这样的逻辑： 在查表的时候，如果一个静态资源有pkg字段，那么就去加载pkg字段所指向的打包文件，否则加载资源本身。 比如执行require_static(&#39;bootstrap.js&#39;)，查表得知bootstrap.js被打包在了p1中，因此取出p1包的url /pkg/lib_cef213d.js，并且记录页面已加载了 jquery.js 和 bootstrap.js 两个资源。这样一来，之前的模板代码执行之后得到的html就变成了： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="/pkg/lib_afec33f.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="/pkg/widgets_af23ce5.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;div&gt; content of module c &lt;/div&gt; &lt;script type="text/javascript" src="/pkg/lib_cef213d.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/pkg/widgets_22feac1.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虽然这种策略请求有4个，不如combo形式的请求少，但可能在统计上是性能更好的方案。由于两个lib打包的文件修改的可能性很小，因此这两个请求的缓存利用率会非常高，每次项目发布后，用户需要重新下载的静态资源可能要比combo请求节省很多带宽。 性能优化既是一个工程问题，又是一个统计问题。优化性能时如果只关注一个页面的首次加载是很片面的。还应该考虑全站页面间跳转、项目迭代后更新资源等情况下的优化策略。 此时，我们又引入了一个新的问题：如何决定哪些文件被打包？ 从经验来看，项目初期可以采用人工配置的方式来指定打包情况，比如： 12345678&#123; "pack" : &#123; "lib.js" : [ "jquery.js", "bootstrap.js" ], "lib.css" : "bootstrap.css", "widgets.js" : "widget/**.js", "widgets.css" : "widget/**.css" &#125;&#125; 但随着系统规模的增大，人工配置会带来非常高的维护成本，此时需要一个辅助系统，通过分析线上访问日志和静态资源组合加载情况来自动生成这份配置文件，系统设计如图： 至此，我们通过基于表的静态资源管理系统和三个模板接口实现了几个重要的性能优化原则，现在我们再来回顾一下前面的性能优化原则分类表，剔除掉已经做到了的，看看还剩下哪些没做到的： 优化方向 优化手段 请求数量 拆分初始化负载 缓存利用 使Ajax可缓存 页面结构 尽早刷新文档的输出 拆分初始化负载 的目标是将页面一开始加载时不需要执行的资源从所有资源中分离出来，等到需要的时候再加载。工程师通常没有耐心去区分资源的分类情况，但我们可以利用组件化框架接口来帮助工程师管理资源的使用。还是从例子开始思考，如果我们有一个js文件是用户交互后才需要加载的，会怎样呢： 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;?php require_static('jquery.js'); ?&gt; &lt;?php require_static('bootstrap.css'); ?&gt; &lt;?php require_static('bootstrap.js'); ?&gt; &lt;!--[ CSS LINKS PLACEHOLDER ]--&gt;&lt;/head&gt;&lt;body&gt; &lt;?php load_widget('a'); ?&gt; &lt;?php load_widget('b'); ?&gt; &lt;?php load_widget('c'); ?&gt; &lt;?php script('start'); ?&gt; &lt;script&gt; $(document.body).click(function()&#123; require.async('dialog.js', function(dialog)&#123; dialog.show('you catch me!'); &#125;); &#125;); &lt;/script&gt; &lt;?php script('end'); ?&gt; &lt;!--[ SCRIPTS PLACEHOLDER ]--&gt;&lt;/body&gt;&lt;/html&gt; 很明显，dialog.js 这个文件我们不需要在初始化的时候就加载，因此它应该在后续的交互中再加载，但文件都加了md5戳，我们如何能在浏览器环境中知道加载的url呢？ 答案就是：把静态资源表的一部分输出在页面上，供前端模块化框架加载静态资源。 我就不多解释代码的执行过程了，大家看到完整的html输出就能理解是怎么回事了： 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;head&gt; &lt;title&gt;page&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="/pkg/lib_afec33f.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="/pkg/widgets_af23ce5.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; content of module a &lt;/div&gt; &lt;div&gt; content of module b &lt;/div&gt; &lt;div&gt; content of module c &lt;/div&gt; &lt;script type="text/javascript" src="/pkg/lib_cef213d.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/pkg/widgets_22feac1.js"&gt;&lt;/script&gt; &lt;script&gt; //将静态资源表输出在前端页面中 require.config(&#123; res : &#123; 'dialog.js' : '/dialog_fa3df03.js' &#125; &#125;); &lt;/script&gt; &lt;script&gt; $(document.body).click(function()&#123; //require.async接口查表确定加载资源的url require.async('dialog.js', function(dialog)&#123; dialog.show('you catch me!'); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dialog.js不会在页面以script src的形式输出，而是变成了资源注册，这样，当页面点击触发require.async执行的时候，async函数才会查表找到资源的url并加载它，加载完毕后触发回调函数。 以上框架示例我实现了一个java版（ https://github.com/fouber/fis-java-jsp ）和一个php版（ https://github.com/fouber/static-resource-management-system-demo ）的示例项目，有兴趣的同学可以参考一下，比阅读文章要更直观一些。 到目前为止，我们又以架构的形式实现了一项优化原则（拆分初始化负载），回顾我们的优化分类表，现在仅有两项没能做到了： 优化方向 优化手段 缓存利用 使Ajax可缓存 页面结构 尽早刷新文档的输出 剩下的两项优化原则要做到并不容易，真正可缓存的Ajax在现实开发中比较少见，而 尽早刷新文档的输出 原则facebook在2010年的velocity上 提到过，就是BigPipe技术。当时facebook团队还讲到了Quickling和PageCache两项技术，其中的PageCache算是比较彻底的实现Ajax可缓存的优化原则了。由于篇幅关系，就不在此展开了，后续还会撰文详细解读这两项技术。 总结其实在前端开发工程管理领域还有很多细节值得探索和挖掘，提升前端团队生产力水平并不是一句空话，它需要我们能对前端开发及代码运行有更深刻的认识，对性能优化原则有更细致的分析与研究。在前端工业化开发的所有环节均有可节省的人力成本，这些成本非常可观，相信现在很多大型互联网公司也都有了这样的共识。 本文只是将这个领域中很小的一部分知识的展开讨论，抛砖引玉，希望能为业界相关领域的工作者提供一些不一样的思路。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程与模块化框架]]></title>
    <url>%2F2015%2F04%2F18%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[前端工程与模块化框架一直酝酿着写一篇关于模块化框架的文章，因为模块化框架是前端工程中的 最为核心的部分 。本来又想长篇大论的写一篇完整且严肃的paper，但看了 @糖饼 在 div.io 的一篇文章 《再谈 SeaJS 与 RequireJS 的差异》觉得可以借着这篇继续谈一下，加上最近spm3发布，在seajs的官网上又引来了一场 口水战 ，我并不想参与到这场论战中，各有所爱的事情不好评论什么，但我想从工程的角度来阐述一下已知的模块化框架相关的问题，并给出一些新的思路，其实也不新啦，都实践了2多年了。 前端模块化框架肩负着 模块管理、资源加载 两项重要的功能，这两项功能与工具、性能、业务、部署等工程环节都有着非常紧密的联系。因此，模块化框架的设计应该最高优先级考虑工程需要。 基于 @糖饼 的文章 《再谈 SeaJS 与 RequireJS 的差异》，我这里还要补充一些模块化框架在工程方面的缺点： requirejs和seajs二者在加载上都有缺陷，就是模块的依赖要等到模块加载完成后，通过静态分析（seajs）或者deps参数（requirejs）来获取，这就为 合并请求 和 按需加载 带来了实现上的矛盾： 要么放弃按需加载，把所有js合成一个文件，从而满足请求合并（两个框架的官方demo都有这样的例子）； 要么放弃请求合并，请求独立的模块文件，从而满足按需加载。 AMD规范在执行callback的时候，要初始化所有依赖的模块，而CMD只有执行到require的时候才初始化模块。所以用AMD实现某种if-else逻辑分支加载不同的模块的时候，就会比较麻烦了。考虑这种情况： 123456789101112//AMD for SPArequire(['page/index', 'page/detail'], function(index, detail)&#123; //在执行回调之前，index和detail模块的factory均执行过了 switch(location.hash)&#123; case '#index': index(); break; case '#detail': detail(); break; &#125;&#125;); 在执行回调之前，已经同时执行了index和detail模块的factory，而CMD只有执行到require才会调用对应模块的factory。这种差别带来的不仅仅是性能上的差异，也可能为开发增加一点小麻烦，比如不方便实现换肤功能，factory注意不要直接操作dom等。当然，我们可以多层嵌套require来解决这个问题，但又会引起模块请求串行的问题。 结论：以纯前端方式实现模块化框架 不能 同时满足 按需加载，请求合并 和 依赖管理 三个需求。 导致这个问题的根本原因是 纯前端方式只能在运行时分析依赖关系。 解决模块化管理的新思路由于根本问题出在 运行时分析依赖，因此新思路的策略很简单：不在运行时分析依赖。这就要借助 构建工具 做线下分析了，其基本原理就是： 利用构建工具在线下进行 模块依赖分析，然后把依赖关系数据写入到构建结果中，并调用模块化框架的 依赖关系声明接口 ，实现模块管理、请求合并以及按需加载等功能。 举个例子，假设我们有一个这样的工程： 12345678910project ├ lib │ └ xmd.js #模块化框架 ├ mods #模块目录 │ ├ a.js │ ├ b.js │ ├ c.js │ ├ d.js │ └ e.js └ index.html #入口页面 工程中，index.html 的源码内容为： 1234567891011121314&lt;!doctype html&gt;...&lt;script src="lib/xmd.js"&gt;&lt;/script&gt; &lt;!-- 模块化框架 --&gt;&lt;script&gt; //等待构建工具生成数据替换 `__FRAMEWORK_CONFIG__' 变量 require.config(__FRAMEWORK_CONFIG__);&lt;/script&gt;&lt;script&gt; //用户代码，异步加载模块 require.async(['a', 'e'], function(a, e)&#123; //do something with a and e. &#125;);&lt;/script&gt;... 工程中，mods/a.js 的源码内容为（采用类似CMD的书写规范）： 123456789define('a', function(require, exports, module)&#123; console.log('a.init'); var b = require('b'); var c = require('c'); exports.run = function()&#123; //do something with b and c. console.log('a.run'); &#125;;&#125;); 具体实现过程 用工具在下线对工程文件进行扫描，得到依赖关系表： 1234&#123; "a" : [ "b", "c" ], "b" : [ "d" ]&#125; 工具把依赖表构建到页面或者脚本中，并调用模块化框架的配置接口，index.html的构建结果为： 123456789101112131415161718&lt;!doctype html&gt;...&lt;script src="lib/xmd.js"&gt;&lt;/script&gt; &lt;!-- 模块化框架 --&gt;&lt;script&gt; //构建工具生成的依赖数据 require.config(&#123; "deps" : &#123; "a" : [ "b", "c" ], "b" : [ "d" ] &#125; &#125;);&lt;/script&gt;&lt;script&gt; //用户代码，异步加载模块 require.async(['a', 'e'], function(a, e)&#123; //do something with a and e. &#125;);&lt;/script&gt; 模块化框架根据依赖表加载资源，比如上述例子，入口需要加载a、e两个模块，查表得知完整依赖关系，配合combo服务，可以发起一个合并后的请求： http://www.example.com/??d.js,b.js,c.js,a.js,e.js 先来看一下这种方案的优点 采用类似CMD的书写规范（同步require函数声明依赖），可以在执行到require语句的时候才调用模块的factory。 虽然采用CMD书写规范，但放弃了运行时分析依赖，改成工具输出依赖表，因此 依赖分析完成后可以压缩掉require关键字 框架并没有严格依赖工具，它只是约定了一种数据结构。不使用工具，人工维护 require.config({...}) 相关的数据也是可以的。对于小项目，文件全部合并的情况，更加不需要deps表了，只要在入口的require.async调用之前加载所有模块化的文件，依赖关系无需额外维护 构建工具设计非常简单，而且可靠。工作就是扫描模块文件目录，得到依赖表，JSON序列化之后插入到构建代码中 由于框架预先知道所有模块的依赖关系，因此可以借助combo服务实现请求合并，而不用等到一级模块加载完成才能知道后续的依赖关系。 如果构建工具可以自动包装define函数，那么整个系统开发起来会感觉跟nodejs非常接近，比较舒服。 再来讨论一下这种方案的缺点：由于采用require函数作为依赖标记，因此如果需要变量方式require，需要额外声明，这个时候可以实现兼容AMD规范写法，比如 123456789define('a', ['b', 'c'], function(require, exports, module)&#123; console.log('a.init'); var name = isIE ? 'b' : 'c'; var mod = require(name); exports.run = function()&#123; //do something with mod. console.log('a.run'); &#125;;&#125;) 只要工具把define函数中的 deps 参数，或者factory内的require都作为依赖声明标记来识别，这样工程性就比较完备了。 但不管怎样， 线下分析始终依靠了字面量信息，所以开发上可能会有一定的局限性，但总的来说瑕不掩瑜。 希望本文能为前端模块化框架的作者带来一些新的思路。没有必要争论规范，工程问题才是最根本的问题。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大公司里怎样开发和部署前端代码？]]></title>
    <url>%2F2015%2F03%2F30%2F%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%87%8C%E6%80%8E%E6%A0%B7%E5%BC%80%E5%8F%91%E5%92%8C%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[大公司里怎样开发和部署前端代码？ 本文搬运自 知乎问题 中的答案。 这是一个非常有趣的 非主流前端领域，这个领域要探索的是如何用工程手段解决前端开发和部署优化的综合问题，入行到现在一直在学习和实践中。 在我的印象中，facebook是这个领域的鼻祖，有兴趣、有梯子的同学可以去看看facebook的页面源代码，体会一下什么叫工程化。 接下来，我想从原理展开讲述，多图，较长，希望能有耐心看完。 让我们返璞归真，从原始的前端开发讲起。上图是一个“可爱”的index.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。前端就是这么简单，好好玩啊，门槛好低啊，分分钟学会有木有！ 然后我们访问页面，看到效果，再查看一下网络请求，200！不错，太™完美了！那么，研发完成。。。。了么？ 等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不“好玩”。 看看那个a.css的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样： 利用304，让浏览器使用本地缓存。但，这样也就够了吗？不成！304叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样： 强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？ 很好，相信有人想到了办法：通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。好像这样： 下次上线，把链接地址改成新的版本，就更新资源了不是。OK，问题解决了么？！当然没有！大公司的变态又来了，思考这种情况： 页面引用了3个css，而某次上线只改了其中的a.css，如果所有链接都更新版本，就会导致b.css，c.css的缓存也失效，那岂不是又有浪费了？！ 重新开启变态模式，我们不难发现，要解决这种问题，必须让url的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应url的变更，从而实现文件级别的精确缓存控制。 什么东西与文件内容相关呢？我们会很自然的联想到利用 数据摘要要算法 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把url改成带摘要信息的： 这回再有文件修改，就只更新那个文件对应的url了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！ 唉~~~~，让我喘口气 现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径： 好了，当我要更新静态资源的时候，同时也会更新html中的引用吧，就好像这样： 这次发布，同时改了页面结构和样式，也更新了静态资源对应的url地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？ 先部署页面，再部署资源：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。 先部署资源，再部署页面：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。 但是，大公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！ 这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。 看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。 所以，大公司的静态资源优化方案，基本上要实现这么几个东西： 配置超长时间的本地缓存 —— 节省带宽，提高性能 采用内容摘要作为缓存更新依据 —— 精确的缓存控制 静态资源CDN部署 —— 优化网络请求 更资源发布路径实现非覆盖式发布 —— 平滑升级 全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在 前端所有静态资源加载的位置都要做这样的处理 。是的，所有！什么js、css自不必说，还要包括js、css文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是： 好了，目前我们快速的学习了一下前端工程中关于静态资源缓存要面临的优化和部署问题，新的问题又来了：这™让工程师怎么写码啊！！！ 要解释优化与工程的结合处理思路，又会扯出一堆有关模块化开发、资源加载、请求合并、前端框架等等的工程问题，以上只是开了个头，解决方案才是精髓，但要说的太多太多，有空再慢慢展开吧。 总之，前端性能优化绝逼是一个工程问题！ 以上不是我YY的，可以观察 百度 或者 facebook 的页面以及静态资源源代码，查看它们的资源引用路径处理，以及网络请中静态资源的缓存控制部分。再次赞叹facebook的前端工程建设水平，跪舔了。 建议前端工程师多多关注前端工程领域，也许有人会觉得自己的产品很小，不用这么变态，但很有可能说不定某天你就需要做出这样的改变了。而且，如果我们能把事情做得更极致，为什么不去做呢？ 另外，也不要觉得这些是运维或者后端工程师要解决的问题。如果由其他角色来解决，大家总是把自己不关心的问题丢给别人，那么前端工程师的开发过程将受到极大的限制，这种情况甚至在某些大公司都不少见！ 妈妈，我再也不玩前端了。。。。5555 业界实践Assets PipelineRails中的Assets Pipeline完成了以上所说的优化细节，对整个静态资源的管理上的设计思考也是如此，了解rails的人也可以把此答案当做是对rails中assets pipeline设计原理的分析。 rails通过把静态资源变成erb模板文件，然后加入&lt;%= asset_path ‘image.png’ %&gt;，上线前预编译完成处理，fis的实现思路跟这个几乎完全一样，但我们当初确实不知道有rails的这套方案存在。 相关资料： 英文版：http://guides.rubyonrails.org/asset_pipeline.html 中文版：http://guides.ruby-china.org/asset_pipeline.html FIS的解决方案用 F.I.S 包装了一个小工具，完整实现整个回答所说的最佳部署方案，并提供了源码对照，可以感受一下项目源码和部署代码的对照。 源码项目：fouber/static-resource-digest-project · GitHub 部署项目：fouber/static-resource-digest-project-release · GitHub 部署项目可以理解为线上发布后的结果，可以在部署项目里查看所有资源引用的md5化处理。 这个示例也可以用于和assets pipeline做比较。fis没有assets的目录规范约束，而且可以以独立工具的方式组合各种前端开发语言（coffee、less、sass/scss、stylus、markdown、jade、ejs、handlebars等等你能想到的），并与其他后端开发语言结合。 assets pipeline的设计思想值得独立成工具用于前端工程，fis就当做这样的一个选择吧。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
